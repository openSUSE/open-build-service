<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.docbook.org/xml/4.4/docbookx.dtd"
[
 <!ENTITY % entities SYSTEM "entity-decl.ent">
 %entities;
]>

<!--
 ***************************************************
 Please see license.xml for this document's license.
 ***************************************************
-->

<sect1 id="sec.kiwi.deploying">
 <title>Real-Life Scenarios - A Tutorial</title>
 <para>When you create an operating system image, you must decide how to activate the image on the
  target system. Because there are many possible target systems, the image deployment depends
  greatly on the system environment. For example, if a customer buys the SLEPOS product, the system
  environment is predetermined, so the he or she must follow the set rules to successfully deploy
  the image. This makes it easy for customers to control a complex system, but it also means that
  you lose the flexibility to use the same system in another environment.</para>
 <para>KIWI doesn't require a specific system environment, and it does leave out some important
  tasks concerning the deployment architecture. So while KIWI is an image creator, it doesn't set up
  the deployment infrastructure. This chapter provides some examples of ways to deploy an image.</para>
 <itemizedlist role="subtoc">
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.net_pxe" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.split_pxe" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.nfs" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.cd.install" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.usb" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.virtual" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.xen" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="sec.kiwi.deploying.live" xrefstyle="SectTitleOnPage"/>
   </para>
  </listitem>
 </itemizedlist>
 <sect2 id="sec.kiwi.deploying.net_pxe">
  <title>Using the PXE Protocol to Deploy an Image via the Network </title>
  <para>PXE is a boot protocol generally implemented in the BIOS or boot ROM of network cards. When
   activated, it searches the network for a DHCP server from which it can obtain an IP address, and
   for information on where to find a TFTP server that can manage file transfers. If such a server
   exists, the second stage bootloader controls the subsequent boot process. Using PXE with KIWI
   requires the infrastructure explained in "The TFTP Server Structure," a TFTP server, and a DHCP server. KIWI provides the
    <systemitem>kiwi-pxeboot</systemitem> package, which sets up the boot structure and installs
   some prebuilt boot images.</para>
  <para>If you plan on using a system image for which no prebuilt boot image exist, you must create
   a custom boot image before a system image can be deployed. Boot images consists of the image
   itself and the appropriate kernel for that image. Both file must be stored in the
    <filename>/srv/tftpboot/boot</filename> directory. Assuming there is no prebuilt boot image for
   the openSUSE 10.2 distribution, the steps to create it are as follows:</para>

  <screen>cd /usr/share/kiwi/image
kiwi --prepare netboot/suse-10.2 --root /tmp/myroot
kiwi --create /tmp/myroot -d /tmp </screen>

  <para>The result of this example is created in the <filename>/tmp</filename> directory:</para>

  <screen>ls -1 /tmp/initrd-netboot*
   /tmp/initrd-netboot-suse-10.2.i686-2.1.1.gz
   /tmp/initrd-netboot-suse-10.2.i686-2.1.1.kernel.2.6.18.2-31-default</screen>
  <para>If you don't want to prepare or create the boot image manually, you can let KIWI do the job
   by setting up the <literal>pxe</literal> type in your system image
   <filename>config.xml</filename> file. For example:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3" boot="netboot/suse-10.2"&gt;pxe&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>

  <para>In this case, the boot image is created automatically, using the same source as the system
   image, when the <literal>\textbf{creation}</literal> step is performed for the system image.</para>
  <para>The next step is to make the boot image known to the TFTP server. To do this, the files must
   be copied to the <filename>/srv/tftpboot/boot</filename> directory. They can also be renamed. For
   the following example, the boot image is renamed to <filename>initrd</filename>, and the boot
   kernel is renamed to <filename>linux</filename>.</para>

  <screen>cp initrd-netboot.i686-2.1.1.gz /srv/tftpboot/boot/initrd
cp initrd-netboot.i686-2.1.1.kernel.2.6.18.2-31-default \
  /srv/tftpboot/boot/linux</screen>


  <para>Switching the target machine on, which must run PXE by default, loads the
   <filename>linux</filename> kernel and the KIWI-created <filename>initrd</filename>. The
    <filename>initrd</filename> registers the machine if no configuration is found in
    <filename>/srv/tftpboot/KIWI</filename>. <quote>Registration</quote> means that a file including
   the MAC address of the machine is uploaded into the <filename>/srv/tftpboot/upload</filename>
   directory. For information on creating the configuration, see &lt;xref
   linkend="sec.kiwi.activating.netboot.configfile" xrefstyle="HeadingOnPage"/>. The following sample
   configuration is for a machine that has a disk on <filename>/dev/sda</filename>: </para>

  <screen>IMAGE=/dev/sda2;my-example-suse-10.2.i686;1.1.2;192.168.100.2;4096
PART=1024;S;x,x;L;/
DISK=/dev/sda</screen>


  <para>According to this configuration, the KIWI boot image tries to download a system image named
    <filename>my-example-suse-10.2.i686-1.1.2</filename> from the TFTP server with an IP address of
   192.168.100.2. On the TFTP server, the system images are stored in
   <filename>/srv/tftpboot/image</filename>. The boot image prepares the disk, and creates a 1 GB
   swap partition and another full-sized linux partition. The process of creating this
    <filename>my-example-suse-10.2</filename> image can be done using KIWI. After the boot image has
   successfully downloaded the system image, it is activated and operates as configured.</para>
 </sect2>
 <sect2 id="sec.kiwi.deploying.split_pxe">
  <title>Deploying a Split Image System via PXE</title>
  <para>KIWI supports system images split into two parts: a read-only part, and a read-write part.
   This lets you put data on different filesystems that usually contain read-only data available on
   a compressed filesystem such as cramfs or squashfs. Almost all available compressed filesystems
   have some kind of restrictions which needs attention before you use it in an image.</para>
  <para>To turn a system image into a split image, only the type of the image must be adapted. This
   information is part of the <filename>config.xml</filename> file, and can be edited as in the
   following example:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3,cramfs"&gt;split&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>Creating an image from this description results in two image files. One of the files
   contains the <literal>-read-write</literal> extension in its name. Booting such an image always
   requires a boot process which must be able to bring both images together again. Because of this,
   split images can only be deployed in combination with one of the KIWI boot images.</para>
  <para>To deploy the image, use PXE or a boot CD/USB-stick. The most important part of using a
   split images is the configuration for the target machine. For more information on this config.MAC
   file, see &lt;xref linkend="sec.kiwi.activating.netboot.configfile" xrefstyle="HeadingOnPage"/>.
   When using a split image, the following information must be
   provided:</para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>The <option>IMAGE</option> key must contain both the read-write and the read-only image.
     The read-only image must appear as the first entry in the list.</para>
   </listitem>
   <listitem>
    <para>The <option>PART</option> key must specify a partition table with at least two
     partitions: an optional swap partition, and two system partitions which provide enough space for the
     first and second image portion.</para>
   </listitem>
   <listitem>
    <para>The <option>COMBINED_IMAGE</option> option, which tells the boot image to combine both
     images into one complete system.</para>
   </listitem>
  </itemizedlist>
  <para>The following example shows the configuration of a split image named <filename>minimal-10.1
    / minimal-10.1-read-only</filename>:</para>

  <screen>IMAGE=/dev/sda2;minimal-10.1-read-only.i686;1.1.2;192.168.100.2;4096,\
      /dev/sda3;minimal-10.1.i686;1.1.2;192.168.100.2;4096
PART=200;S;x,500;L;/,x;L;
DISK=/dev/sda
COMBINED_IMAGE=yes</screen>


 </sect2>
 <sect2 id="sec.kiwi.deploying.nfs">
  <title> Using an NFS Mounted <systemitem>root</systemitem> System to Deploy an Image via the
   Network </title>
  <para>KIWI was designed to upload an image onto a client in several different ways, including onto
   diskless machines. These devices don't provide permanent storage, and rely on the network. The
   most often-used process to activate such terminals is to NFS-mount the system image via the
   network. KIWI supports this as well, but it requires a terminal server configuration to export
   the system image using a NFS server.</para>
  <para>To activate a diskless station, use the following steps:</para>
  <procedure id="bc483y1">
   <step id="bc483y2" performance="required">
    <para>Prepare the system image using the following command: </para>

    <screen>kiwi --root /tmp/kiwi.nfsroot --prepare ...</screen>

   </step>
   <step id="bc4840s" performance="required">
    <para>Set up an NFS server which exports the <filename>/tmp/kiwi.nfsroot</filename> path. </para>
    <para>We recommend using the following export options in <filename>/etc/exports</filename>:</para>

    <screen>/tmp/kiwi.nfsroot  *(rw,no_root_squash,sync,no_subtree_check) </screen>

   </step>
   <step id="bc4842s" performance="required">
    <para>Use KIWI to create an appropriate netboot boot image (<filename>initrd</filename>).</para>
    <para><quote>Appropriate</quote> means that the package repository for the system image and the
     netboot image are the same.</para>
   </step>
   <step id="bc4848m" performance="required">
    <para>Copy the boot image/kernel to the PXE server in <filename>/srv/tftpboot/boot</filename>.</para>
    <para>The <systemitem>kiwi-pxeboot</systemitem> package helps you set up the PXE/TFTP
    server.</para>
   </step>
   <step id="bc4849t" performance="required">
    <para>Create a <filename>config.&lt;<replaceable>MAC</replaceable>></filename> file in
      <filename>/srv/tftpboot/KIWI</filename> with the following contents:</para>

    <screen>NFSROOT=129.168.100.7;/tmp/kiwi.nfsroot</screen>

   </step>
   <step id="bc484by" performance="required">
    <para>Boot the client.</para>
    <para>If everything works properly, the client receives the boot image and kernel via PXE/TFTP.
     The boot image NFS mounts the system image according to the data in
      config.&lt;<replaceable>MAC</replaceable>>. After that, the mounted root filesystem is
     activated.</para>
   </step>
  </procedure>
 </sect2>
 <sect2 id="sec.kiwi.deploying.cd.install">
  <title>Installing an Image from a CD, DVD, or USB Stick</title>
  <para>You can create a CD, DVD, or USB stick which contains an image you want to install on the
   hard disk of a computer. The installation process in KIWI is rather simple, but it doesn't
   consider previously installed operating systems or disk partitions, so be careful with this
   deployment method.</para>
  <para>The process of booting a CD with an image as the content and the later first boot of this
   image is handled by the KIWI oemboot boot image. The system image in this case must be a virtual
   disk type, which requires oemboot to be used in combination with the vmx image type. To indicate
   that the resulting virtual disk system image should be part of an ISO and the later install CD,
   set the attribute format with the value of <literal>iso</literal>. The system image description
   requires the following type specification:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3" boot="oemboot/suse-... format="iso"&gt;vmx&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>To indicate that the resulting virtual disk system image should be part of a installation
   virtual disk which can be dumped on an USB stick, the value <literal>usb</literal> must be
   set.The system image description requires the following type specification:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3" boot="oemboot/suse-... format="usb"&gt;vmx&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>Use the following KIWI commands to create an install ISO image:</para>

  <screen>kiwi --prepare /path/to/the/system/image/description --root /tmp/myRoot
kiwi --create /tmp/myRoot</screen>

  <para>The command creates a bootable ISO image which should be burned on a CD. KIWI informs the
   user about the file name to be burned on CD or DVD. </para>
 </sect2>
 <sect2 id="sec.kiwi.deploying.usb">
  <title>USB Stick System</title>
  <remark>Author: Jan-Christoph Bornschlegel</remark>
  <para>It has become popular to store complete operating systems on a USB stick. All required
   system and user data is stored completely on the stick.</para>
  <para>This tutorial explains how to create a bootable USB system on a concrete device. Several
   assumptions are made, and the process is described step-by-step. This section also includes an
   overview of known problems to help you avoid false positives. </para>
  <itemizedlist role="subtoc">
   <listitem>
    <para>
     <xref linkend="sec.kiwi.deploying.usb.assumptions" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec.kiwi.deploying.usb.workflow" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec.kiwi.deploying.usb.configxml" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec.kiwi.deploying.usb.prepare" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
   <listitem>
    <para>
     <xref linkend="sec.kiwi.deploying.usb.modify" xrefstyle="HeadingOnPage"/>
    </para>
   </listitem>
  </itemizedlist>
  <sect3 id="sec.kiwi.deploying.usb.assumptions">
   <title>USB Assumptions</title>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>A bootable USB image is the result.</para>
    </listitem>
    <listitem>
     <para>Either openSUSE or a compatible Linux derivative is available on the build host.</para>
    </listitem>
    <listitem>
     <para>The latest version of KIWI is installed, with the following required packages:</para>
     <itemizedlist mark="bullet" spacing="normal">
      <listitem>
       <para>
        <filename>kiwi</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>kiwi-desc-usbboot</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>kiwi-desc-livesystem</filename>
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  <para>The livesystem package contains several example descriptions and is not mandatory. If another source of configuration files is available, it can be ignored.</para>
   <para>You can download and install these packages from the openSUSE BuildService, or you can
    obtain the latest svn snapshot from svn.berlios.de.</para>
    <para>If the svn version is used, beware of the fact that no package management takes care of resolving dependencies.
    This may manifest itself in very strange error messages. To be on the safe side and not run into those problems one per run,
    you can analyse the RPM's requirements manually and install all required software, or you install the packages and uninstall them again,
    or you risk a mix system which is absolutely not recommended.
    Plus one problem remains: the make process requires some tools that may be missing although the RPM archives are installed.
    For example <systemitem>jing</systemitem> is used for XML-RelaxNG validation during the build.</para>
   <procedure id="bc4954d">
    <step id="bc4954e" performance="required">
     <para>Check out the latest version from svn.berlios.de.</para>

     <screen>
svn co https://<replaceable>anonymous</replaceable>@svn.berlios.de/svnroot/repos/kiwi/kiwi-head
</screen>

     <para>Replace <replaceable>anonymous</replaceable> with a valid BerliOS account if one is
      available.</para>
    </step>
    <step id="bc495lo" performance="required">
     <para>Make sure that the package <filename>kiwi-desc-usbboot</filename> and optionally <filename>kiwi-desc-livesystem</filename> are
      installed.</para>

     <screen>rpm -qa kiwi*</screen>

    </step>
    <step id="bc496bm" performance="required">
     <para>Change to the kiwi checkout directory (where the makefile resides), then execute the
      following:</para>

     <screen>make &amp;&amp; [sudo] make install</screen>


     <para>The <systemitem>root</systemitem> privileges are required to perform the install step because
      files are copied to <filename>/usr/share/kiwi</filename> and <filename>/usr/sbin</filename>.
      It might be necessary to add the sudo command prefix if the previous commands were run as a
      normal user.</para>
    </step>
    <step id="bc496i2" performance="required">
     <para>Create a working directory (recommended in <literal>$HOME</literal>), for example
       <filename>configs</filename>, and check out the image descriptions from forgesvn1.novell.com.</para>

     <screen>svn co https://forgesvn1.novell.com/svn/opensuse/trunk/distribution/images <filename>configs</filename></screen>


    </step>
   </procedure>
   <para>After this procedure, KIWI is installed as <filename>/usr/sbin/kiwi</filename>, and the
    image descriptions in <filename>/usr/share/kiwi/images/</filename>. These subdirectories contain
     <filename>config.xml</filename> files, which are used by the <command>kiwi</command> command
    internally, and must not be modified for any reason. If <command>kiwi</command> is installed
    from the subversion repository, it will not show up as an installed package. The rpm files
    contain dependencies that must be resolved manually. A list of dependencies is collected in the
     <filename>README</filename> file in the base directory of the KIWI repository.</para>
  </sect3>
  <sect3 id="sec.kiwi.deploying.usb.workflow">
   <title>USB Workflow</title>
   <para>The main workflow consists of three consecutive commands shown in the following example:</para>
 
		<example id="ex.kiwi.deploying.usb.workflow.1">
    <title>Basic kiwi Commands</title>
   <screen>kiwi -r &lt;rootdir&gt; --prepare &lt;imagedir&gt;
kiwi --create &lt;rootdir&gt; --type usb -d &lt;outputdir&gt;
kiwi --bootstick &lt;outputdir&gt;/initrd*.gz \
     --bootstick-system &lt;outputdir&gt;/&lt;imagefile&gt;;</screen>
   </example>

   <para>In this example, the terms in braces (&lt; >) have the following meaning and
    requirements: </para>
   <variablelist>
    <title>Explanation of Options</title>
    <varlistentry id="bc4moae">
     <term>rootdir</term>
     <listitem>
      <para>Specifies the directory where the installed system is created. This directory is created
       by the <command>kiwi</command> command. If it existed previously, before,
       <command>kiwi</command> exits with a warning message.</para>
     </listitem>
    </varlistentry>
    <varlistentry id="bc4mpag">
     <term>imagedir</term>
     <listitem>
      <para>Specifies the location of your edited <filename>config.xml</filename> file.</para>
     </listitem>
    </varlistentry>
    <varlistentry id="bc4mqbi">
     <term>outputdir</term>
     <listitem>
      <para>Specifies the location of the following generated output files:</para>
      <itemizedlist id="lst.usbboot.workflow.files" mark="bullet" spacing="normal">
      <title>Result Files of Second Stage</title>
       <listitem>
        <para>
         <filename>initrd-*.gz</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-*.kernel</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-*.kernel.&lt;<replaceable>version</replaceable>>;&lt;<replaceable>type</replaceable>></filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-*.md5 -- the MD5 checksum</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-*.stickboot</filename>
        </para>
       </listitem>
       <listitem>
        <para><filename>&lt;<replaceable>imagefile</replaceable>></filename> as named in the
         first line of <filename>config.xml</filename></para>
        <para>For example:
         <filename>USB-Image-suse-10.3-Alpha5-Plus-&lt;arch>-&lt;version></filename></para>
       </listitem>
       <listitem>
        <para>imagefile's md5 sum</para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>There are several areas where the user can modify the image creation. These areas are
    explained in the respective sections where the interaction makes sense.</para>
  </sect3>
  <sect3 id="sec.kiwi.deploying.usb.configxml">
   <title>Preparing <filename>config.xml</filename> for USB</title>
   <para>Several changes should be made to the <filename>config.xml</filename> file delivered with
    the <filename>kiwi-desc-livesystem</filename> package. For example, the correct installation
    source must be used. In SuSE internal builds, the FACTORY tree is used. If FACTORY is
    currently rebuilt or in an unsynchronous state, you can use another installation source, such as
     <filename>/mounts/dist/install/SLP/openSUSE-10.3-LATEST-DVD/i386/DVD1</filename>.Unfortunately,
    there are no <filename>squashfs</filename> and <filename>aufs</filename> packages in this tree,
    so you will have to import these packages from another location.</para>
   <para>If necessary, you can declare multiple installation sources. Any folder containing multiple
    RPM files that must be installed additionally (which are not already contained in a repository)
    can be added as a repository. A sample configuration file is shown here: </para>


   <!--\begin{lstlisting}[language=xml, label={lst:config-xml-example}, caption={\textit{config.xml} File}]-->
   <example id="config.xml.example">
   <title>Example USB Configuration File</title>
   <screen linenumbering="numbered">&lt;image name="USB-Image-suse-10.3-Alpha5plus"&gt;
	&lt;description type="system"&gt;
		&lt;author&gt;Jan-Christoph Bornschlegel&lt;/author&gt;
		&lt;contact&gt;jcbornschlegel@novell.com&lt;/contact&gt;
		&lt;specification&gt;openSUSE 10.3 USB boot system&lt;/specification&gt;
	&lt;/description&gt;
	&lt;preferences&gt;
		&lt;type primary="true" boot="isoboot/suse-10.3" flags="unified"&gt;iso&lt;/type&gt;
		&lt;type boot="vmxboot/suse-10.3" filesystem="ext3" format="vmdk"&gt;vmx&lt;/type&gt;
		&lt;type boot="xenboot/suse-10.3" filesystem="ext3"&gt;xen&lt;/type&gt;
		&lt;type boot="usbboot/suse-10.3" filesystem="squashfs"&gt;usb&lt;/type&gt;
		&lt;version&gt;1.1.2&lt;/version&gt;
		&lt;size unit="M"&gt;2000&lt;/size&gt;
		&lt;packagemanager&gt;smart&lt;/packagemanager&gt;
		&lt;rpm-check-signatures&gt;False&lt;/rpm-check-signatures&gt;
		&lt;rpm-force&gt;True&lt;/rpm-force&gt;
	&lt;/preferences&gt;
	&lt;users group="users"&gt;
		&lt;user name="linux" pwd="..." home="/home/linux"/&gt;
	&lt;/users&gt;
	&lt;repository type="yast2"&gt;
		&lt;source path="opensuse://SL-OSS-factory"/&gt;
	&lt;/repository&gt;
	&lt;repository type="rpm-dir"&gt;
		&lt;source path="[some plain RPM dir]"/&gt;
	&lt;/repository&gt;
	&lt;packages type="image" patternType="plusSuggested"&gt;
		&lt;package name="subversion"/&gt;
		&lt;package name="xkeyboard-config"/&gt;
		&lt;package name="vim"/&gt;
		&lt;package name="yast2-schema"/&gt;
		&lt;package name="yast2-theme-openSUSE"/&gt;
		&lt;package name="yast2-control-center"/&gt;
		&lt;package name="yast2-control-center-qt"/&gt;
		&lt;package name="yast2-live-installer"/&gt;
		&lt;opensusePattern name="default"/&gt;
		&lt;opensusePattern name="base"/&gt;
		&lt;opensusePattern name="enhanced_base"/&gt;
		&lt;opensusePattern name="x11"/&gt;
		&lt;opensusePattern name="yast2_basis"/&gt;
		&lt;opensusePattern name="yast2_install_wf"/&gt;
		&lt;opensusePattern name="apparmor"/&gt;
		&lt;opensusePattern name="imaging"/&gt;
		&lt;opensusePattern name="kde"/&gt;
		&lt;opensusePattern name="kde_basis"/&gt;
		&lt;opensusePattern name="kde_imaging"/&gt;
		&lt;opensusePattern name="office"/&gt;
		&lt;ignore  name="ash"/&gt;
		...
		<!--&lt;ignore  name="black-box"/&gt;
		&lt;ignore  name="delayacct-utils"/&gt;
		&lt;ignore  name="kdeedu3"/&gt;
		&lt;ignore  name="pfstmo"/&gt;
		&lt;ignore  name="pfstools"/&gt;
		&lt;ignore  name="synergy"/&gt;
		&lt;ignore  name="yast2-cd-creator"/&gt;
		&lt;ignore  name="smtp_daemon"/&gt;
		&lt;ignore  name="pfscalibratio"/&gt;
		&lt;ignore  name="jaf-demo"/&gt;
		&lt;ignore  name="jaf-javadoc"/&gt;
		&lt;ignore  name="jaf-manual"/&gt;
		&lt;ignore  name="jai"/&gt;
		&lt;ignore  name="java-1_4_2-sun"/&gt;
		&lt;ignore  name="java-1_4_2-sun-alsa"/&gt;
		&lt;ignore  name="java-1_4_2-sun-devel"/&gt;
		&lt;ignore  name="java-1_4_2-sun-jdbc"/&gt;
		&lt;ignore  name="java-1_4_2-sun-plugin"/&gt;
		&lt;ignore  name="javamail-manual"/&gt;
		&lt;ignore  name="jmx-javadoc"/&gt;
		&lt;ignore  name="jta-javadoc"/&gt;
		&lt;ignore  name="mcelog"/&gt;
		&lt;ignore  name="numactl"/&gt;
		&lt;ignore  name="wesnoth-data-small"/&gt;
		&lt;ignore  name="sendmail"/&gt;
		&lt;ignore  name="exim"/&gt;
		&lt;ignore  name="AdobeICCProfiles"/&gt;
		&lt;ignore  name="RealPlayer"/&gt;
		&lt;ignore  name="agfa-fonts"/&gt;
		&lt;ignore  name="flash-player"/&gt;
		&lt;ignore  name="java-1_5_0-sun"/&gt;
		&lt;ignore  name="java-1_5_0-sun-plugin"/&gt;
		&lt;ignore  name="java-1_5_0-sun-jdbc"/&gt;
		&lt;ignore  name="java-1_5_0-sun-devel"/&gt;
		&lt;ignore  name="java-1_5_0-sun-alsa"/&gt;
		&lt;ignore  name="opensuse-quickstart_en"/&gt;
		&lt;ignore  name="util-linux-crypto"/&gt;-->
		&lt;ignore  name="krb5-32bit"/&gt;
	&lt;/packages&gt;
	&lt;packages type="xen" memory="512" disk="/dev/sda"&gt;
		&lt;package name="kernel-xen"/&gt;
		&lt;package name="xen"/&gt;
	&lt;/packages&gt;
	&lt;packages type="vmware" memory="512" disk="ide0"&gt;
	&lt;/packages&gt;
    &lt;packages type="boot"&gt;
        &lt;package name="filesystem"/&gt; 
        &lt;package name="glibc-locale"/&gt;
		&lt;package name="kernel-default"/&gt;
        &lt;package name="devs"/&gt;
    &lt;/packages&gt;
&lt;/image&gt;</screen>
   </example>

   <para>First, the image needs a name, which sets the filename mentioned in <xref
     linkend="sec.kiwi.deploying.usb.workflow" xrefstyle="HeadingOnPage"/> as &lt;imagename>
    (line 1). Then set the author and contact information. Lines 9-11 set the respective
    configurations for the desired image type. To use a specific type, the folder
     <filename>/usr/share/kiwi/image/&lt;type entry></filename> must already exist. You might
    have to check out additional modules or install additional
    <filename>kiwi-desc-&lt;type></filename> packages.</para>
   <para>The <option>version</option> tag in line 12 is added to the image's filename. The
     <option>size</option> option mentioned in line 13 is the size to which the stick's filesystem
    is expanded at first boot. The additional installation source (in this case, a plain directory
    containing some RPM files) is added in lines 28-20.</para>
   <para>The majority of changes are made in the &lt;package name="..."/&gt; section. The
     <varname>&lt;package name="something"/&gt;</varname> tag adds the
    &lt;something-*.rpm&gt; package to the installation, where "*" is a mix of version
    number, release number and architecture. The <varname>&lt;opensusePattern
    name="somepattern"/&gt;</varname> tag adds all packages required by the
    &lt;somepattern&gt; pattern to the installation. The <varname>&lt;ignore
     name="someignoredpackage"/&gt;</varname> tag omits the &lt;someignoredpackage&gt;
    package. This is an ugly method used to resolve pattern bugs. It happens when a pattern requires
    a package that cannot be resolved because it does not exist in the given installation sources
    (or the name changed). If this happens, the <varname>prepare</varname> step must be repeated
    (see <xref linkend="sec.kiwi.deploying.usb.prepare" xrefstyle="HeadingOnPage"/> for more
    information).</para>

  </sect3>
  <sect3 id="sec.kiwi.deploying.usb.prepare">
   <title>Preparing the Installation Source Directory</title>
   <para>The prepare step collects all packages listed in the <filename>config.xml</filename> file
    and all packages required by the included patterns. Use the <option>-r</option> option to
    specify the target directory which is created by <command>kiwi</command>. An error message is
    reported if the directory already exists.</para>
   <para>This step reveals all pattern problems and missing packages. Unfortunately, these issues
    must be fixed manually using the techniques described below. Unresolved dependencies can be a
    severe problem because it shows that some package should be in the installation source but are
    not. In that case, several solutions are possible: </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>Find the package somewhere else and put it in using the <literal>&lt;package
       name="..."/></literal> tag.</para>
    </listitem>
    <listitem>
     <para>If a lot of packages are missing, and all of them can be found in the same repository,
      use the <literal>&lt;repository type="..."> ...&lt;/repository></literal> tags.</para>
    </listitem>
    <listitem>
     <para>The packages can be stored in a local directory, and that directory can be declared as an
      additional installation source of the type "rpm-dir" (plain RPM directory). In that case, the
      line looks like this:</para>

     <screen>&lt;repository type="rpm-dir"&gt;
&lt;source path="/some/directory/where/be/RPMS/"/&gt;
&lt;/repository&gt;</screen>


    </listitem>
   </itemizedlist>
  </sect3>
  <sect3 id="sec.kiwi.deploying.usb.modify">
   <title>Modifying the Installation Source Directory</title>
   <para>After the <option>--prepare</option> step is successfully completed, the installation
    source can be modified further. You can always perform a <command>chroot</command> command, then
    install packages using <command>smart</command> or <command>rpm</command>. The rpms must be
    accessible through the available channels, which means that you can add anything listed in the
    repositories declared in the <filename>config.xml</filename> file, or you can copy (or hardlink)
    them somewhere in the chroot environment before you chrooting there.</para>
   <para>Be aware that the <command>smart</command> command cannot resolve certain dependencies. For
    example, if you have the packages <filename>yast2-control-center</filename> and
     <filename>yast2-control-center-qt</filename> copied or linked to
     <filename>&lt;rootdir>;/tmp</filename>, you can install by calling the following commands:</para>

   <screen id="invoke-smart-in-chroot">cp /some/directory/where/be/RPMS/yast2-* &lt;rootdir&gt;/tmp
chroot &lt;rootdir&gt;
smart install /tmp/yast2-control-center /tmp/yast2-control-center-qt</screen>


   <para>If you install only <filename>yast2-control-center-qt</filename>, <command>smart</command>
    will not find <filename>yast2-control-center</filename> although it is required. This is why it
    is necessary to specify both packages if you use <command>smart</command>. </para>
   <para>All of the repositories specified in the configuration file are added as
    <command>smart</command> channels, and any package within these channels can be manually
    installed after the prepare step if necessary. You can also uninstall packages if the image
    becomes too large. </para>

  </sect3>

  <sect3 id="sec.kiwi.deploying.usb.create" lang="en">
   <title>Creating the USB Images</title>
   <para>
The images can be created as soon as everything is prepared in the chroot environment.
Simply run the second command in <xref linkend="ex.kiwi.deploying.usb.workflow.1" xrefstyle="HeadingOnPage"/>.
The target directory &lt;outputdir&gt; must be manually created before, in contrast to the prepare step where <command>kiwi</command> creates the directory.
Some of the "failed" messages can be safely ignored because they reflect known bugs and do not break the image creation.
The files created are listed in <xref linkend="lst.usbboot.workflow.files" xrefstyle="HeadingOnPage"/>.
   </para>
   <para>
You can create images for different architecures in the same target directory, because the filenames include the architectue.
   </para>
  </sect3>

  <sect3 id="sec.kiwi.deploying.usb.dump" lang="en">
  <title>Dump the USB Images on the USB Device</title>
   <para>
As the images are eventually created they can be dumped on the USB device.
Some things must be considered before:
   </para>
   <itemizedlist id="lst.kiwi.deploying.usb.dump.caution">
   <title>Considerations before Dump</title>
    <listitem>
     <para>
		Any data on the stick before will be lost
     </para>
    </listitem>
    <listitem>
     <para>
		  It is not possible to save a partition
     </para>
    </listitem>
   </itemizedlist>

   <para>
   <command>kiwi</command> will request the device file after it computes a list of possible devices.
All connected USB "writable" devices should be listed; it is recommended to verify using for example <command>dmesg</command>.
After the correct device file was entered the filesystem on the stick is created.
This may take several minutes depending on the stick's write speed.
There is a mathod for checking the progress. <command>Kiwi</command> uses <command>dd</command> to write the image on the device, so you can send the respective process a signal <systemitem>USR1</systemitem>.
As result <command>dd</command> prints its current statistics to <systemitem>stdout</systemitem> and continues normally.
   </para>
   <example id="ex:trick-dd-progress">
   <title>How to Retrieve <command>dd</command> status</title>
   <screen>cd newimage
kiwi -bootstick initrd-usbboot-suse-10.3.i686-2.1.1.gz \
-bootstick-system USB-Image-suse-10.3-Factory.i686-1.1.2
(other shell)
killall -USR1 dd</screen>
   </example>
  </sect3>


  <sect3 id="sec.kiwi.deploying.usb.issues" lang="en">
  <title>Known Issues</title>
   <para>
There have been tests with mini-harddisk USB devices which showed some problems on some machines.
Some problems arise trying to boot a laptop with special input devices (IBM ThinkPad with its joystick device for example), touchpad support is still a missing item.
   </para>
   <para>
Another known problem is the workaround time to fix missing package dependencies.
It happened with some installation sources that several packages were missing.
It is also strongly recommended not to modify the repositories themselves because then the metadata becomes incorrect and must be recreated.
This is possible, but not very convenient.
   </para>
   <para>
Conflicts may arise depending on the used <command>smart</command> version, especially in one particular case:
The host system's <command>smart</command> is used for the first stage of the image creation, the changeroot environment.
For the second step the version installed in the changeroot environment is used.
This leads to problems if the host's version is newer and can handle <command>gzip</command> compressed metadata and the installed version can not.
   </para>
  </sect3>
 </sect2>

 <sect2 id="sec.kiwi.deploying.oemboot">
  <title>OEM Boot System</title>
  <remark>Author: Jan-Christoph Bornschlegel</remark>
  <sect3 id="sec.kiwi.deploying.assumptions">
   <title>OEM Assumptions</title>
   <para>
    This tutorial explains how a preload harddisk image is created with <command>kiwi</command>.
    A harddisk image allows hardware vendors to deploy a preconfigured system with the hardware
    to achieve convenient use and cost effective installation at the same time.
   </para>
   <para>
    The image will be prepared and configured once and then deployed to many computers using a
    simple copy.
   </para>
   <para>
    In addition to the packages and preconditions mentioned in 
    <xref linkend="sec.kiwi.deploying.usb.assumptions" xrefstyle="HeadingOnPage"/>
    one more package must be installed which contains the OEM boot configuration and scripts:
    <package>kiwi-desc-oemboot</package>. Alternatively the files can also be obtained from
    the kiwi subversion repository. If you decide to use the repository version of <command>kiwi</command>
    the folder is already checked out.
   </para>
  </sect3>
  <sect3 id="sec.kiwi.deploying.workflow">
   <title>OEM Workflow</title>
   <para>
    The workflow is comparable to the USB workflow as described in <xref linkend="sec.kiwi.deploying.usb" xrefstyle="HeadingOnPage"/>
    but involves only two <command>kiwi</command>
    invocations. Deployment is done by any copy mechanism, for example as simple as <command>dd</command>.
   </para> 
		<example id="ex.kiwi.deploying.oem.workflow.1">
    <title>Basic kiwi Commands for OEM</title>
   <screen>kiwi -r &lt;rootdir&gt; --prepare &lt;imagedir&gt;
kiwi --create &lt;rootdir&gt; -d &lt;outputdir&gt;</screen>
   </example>
   <para>
     The files in brackets have exactly the same meaning as explained in <xref linkend="sec.kiwi.deploying.usb.workflow" xrefstyle="HeadingOnPage"/>,
     the resulting files are different:
   </para>
      <itemizedlist id="lst.oemboot.workflow.files" mark="bullet" spacing="normal">
      <title>Result Files of Second Stage OEM</title>
       <listitem>
        <para>
         <filename>initrd-oemboot-*.gz</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-oemboot-*.kernel</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-oemboot-*.kernel.&lt;<replaceable>version</replaceable>>;&lt;<replaceable>type</replaceable>></filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>initrd-oemboot-*.md5 -- the MD5 checksum</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename></filename>
        </para>
       </listitem>
       <listitem>
        <para><filename>&lt;<replaceable>imagefile</replaceable>></filename> as named in the
         first line of <filename>config.xml</filename> plus architecture and version number</para>
        <para>For example:
         <filename>preload-suse-SLED10.i686-1.1.2</filename></para>
       </listitem>
       <listitem>
        <para>imagefile's md5 sum</para>
       </listitem>
       <listitem>
        <para>The image as dumpable file (extension .raw)</para>
        <para>For example:
         <filename>preload-suse-SLED10.i686-1.1.2.raw</filename></para>
       </listitem>
      </itemizedlist>

   <para>
    The ".raw" file can be dumped to the harddisk of the target system directly.
    For distribution, download or a recovery disk the image can be shrinked using
    <command>gzip</command>.
    In test environment we used the following method for deployment:
   </para>
    <procedure id="proc.kiwi.deploying.oemboot.deploy">
    <title>Deploying the OEM Image on Test Machine</title>
     <step>
      <para>Boot the test machine from any device but harddisk.</para>
      <para>This is a very beautiful use case for the USB boot image explained in
       <xref linkend="sec.kiwi.deploying.usb" xrefstyle="HeadingOnPage"/>.</para>
     </step>
     <step>
      <para>Create a NFS export on the machine which hosts the image.</para>
      <para>Edit the file <filename>/etc/exports</filename> and add a line like this:</para>
      <screen>/folder/on/host	*.&gt;domain>(ro,root_squash,sync)</screen>
      <para>Restart (or start) the NFS server:</para>
      <screen>[sudo] rcnfsserver restart</screen>
      <para>Additionally it may be necessary to add the NFS port in your firewall configuration.</para>
     </step>
     <step>
      <para>mount the exported diretory on the test machine:</para>
      <screen>mount <replaceable>host</replaceable>:<replaceable>folder</replaceable> <replaceable>mountpoint</replaceable></screen>
     </step>
     <step>
      <para>Dump the image to the harddisk using the device file.</para>
      <screen>dd if=<replaceable>mountpoint</replaceable>/<replaceable>imagefile</replaceable> of=/dev/sda</screen>
      <para>In case of a compressed image these commands must be:</para>
      <screen>zcat <replaceable>mountpoint</replaceable>/<replaceable>imagefile</replaceable>.gz | dd of=/dev/sda</screen>
     </step>
    </procedure>
  </sect3>

  <sect3 id="sec.kiwi.deploying.oem.issues" lang="en">
  <title>OEM Image Known Issues</title>
   <para>
    The workaround time is rather long if the image has a lot of packages installed.
    The <filename><replaceable>imagename</replaceable>.raw file</filename> becomes huge if you set a size in
    the <filename>config.xml</filename> file. If you comment this line, <command>kiwi</command> determines a size
    automatically which is rather small. Even with this it is still possible to compress the image and save
    another 30-50% of the size which allows the image to fit on a single layer DVD for instance for recovery disks.
   </para>
  </sect3>
 </sect2>

 <sect2 id="sec.kiwi.deploying.virtual">
  <title>Using a Virtual Disk System (QEMU or VMware)</title>
  <para>To use a virtualized system, you must first create a virtual disk. You can do this by
   specifying the following <literal>type</literal> in the system's image
   <filename>config.xml</filename> file:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3" boot="vmxboot/suse-10.2"&gt;vmx&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>After you do this, you can create the system image. The process creates the system image and
   the specified boot image (<filename>vmxboot/suse-10.2</filename> in our example). The result is
   then used to create the virtual disk. To create the system image, use the following command:</para>

  <screen>kiwi --prepare my-example-suse-10.2 --root /tmp/mysystem
kiwi --create /tmp/mysystem -d /tmp</screen>


  <para>The result of this command is a set of virtual disks, one with a <filename>.qemu</filename>
   suffix (QEMU), and one with a <filename>.vmdk</filename> suffix (VMware). To run the system on
   the virtual disk (with qemu as the example), use the following:</para>

  <screen>qemu /tmp/my-example-suse-10.2.i686-1.1.2.qemu</screen>

 </sect2>
 <sect2 id="sec.kiwi.deploying.xen">
  <title>Using a Paravirtual Image with Xen</title>
  <para>To use an image within Xen, create a system image and an <filename>initrd</filename> file.
   You can do this by specifying the following <literal>type</literal> in the system's image
    <filename>config.xml</filename> file:</para>

  <screen>&lt;preferences&gt;
  &lt;type filesystem="ext3" boot="xenboot/suse-10.2"&gt;xen&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>After you do this, you can create the system image. The process creates the system image and
   the specified boot image (<filename>xenboot/suse-10.2</filename> in our example). An appropriate
   Xen configuration file, with a <filename>.xenconfig</filename> suffix, is also created. To create
   the system image, use the following command:</para>

  <screen>kiwi --prepare my-example-suse-10.2 --root /tmp/mysystem
kiwi --create /tmp/mysystem -d /tmp</screen>


  <para>To run the system within Xen, use the following command: </para>

  <screen>xm create -c /tmp/my-example-suse-10.2.i686-1.1.2.xenconfig</screen>


 </sect2>
 <sect2 id="sec.kiwi.deploying.live">
  <title>Using a Live CD System</title>
  <para>LiveDistro or Live CD is a generic term for an operating system distribution that is
   executed upon boot, without installation, on a hard drive. Typically, it is stored on a bootable
   medium, such as a CD-ROM (Live CD) or DVD (Live DVD). The term "live" comes from the fact that
   these distributions are a complete, runnable (that is, "live") instance of the operating system
   residing on the distribution medium, rather than the typical collection of packages that must
   first be installed on the target machine before using the operating system.</para>
  <para>A LiveDistro does not alter the current operating system or files unless the user
   specifically requests it. The system returns to its previous state when the LiveDistro is ejected
   and the computer is rebooted. It does this by placing the files that are typically stored on the
   hard drive into temporary memory, such as a RAM disk. In fact, a hard drive is not needed at all.
   However, the lack of a hard drive cuts down on the RAM available to applications, which can
   reduce performance.</para>
  <para>To create an <filename>.iso</filename> image that can be burned on CD, specify the boot
   image that should handle your live system. You can do this by setting the <literal>type</literal>
   of the image in the <filename>config.xml</filename> file as follows:</para>

  <screen>&lt;preferences&gt;
  &lt;type boot="isoboot/suse-10.3"&gt;iso&lt;/type&gt;
  ...
&lt;/preferences&gt;</screen>


  <para>The <literal>boot</literal> attribute specifies the CD boot image which must exist in
    <filename>/usr/share/kiwi/image/isoboot</filename>. As with all boot images, the most important
   point is that the boot image must match the operating system image. This means that the kernel of
   the boot and operating system image must be the same. If you don't have a boot image that matches
   your operating system image, you should create your own boot image description. You can use an
   existing boot image and adapt it to your needs.</para>
 </sect2>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
coding:utf-8
mode:xml
sgml-indent-step:1
sgml-omittag:nil
sgml-shorttag:nil
End:
-->
