#!/usr/bin/perl -w
#
# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.
# Copyright (c) 2008 Adrian Schroeter, Novell Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# The Source Server
#

BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd/build";
  unshift @INC,  "$wd";
}

use XML::Structured ':bytes';
use Data::Dumper;
use Storable ();
use Symbol;

use BSConfig;
use BSRPC ':https';
use BSServer;
use BSUtil;
use BSFileDB;
use BSXML;
use BSVerify;
use BSHandoff;
use BSWatcher ':https';
use BSXPath;
use BSStdServer;
use BSSrcdiff;
use Build;
use BSHermes;

use BSXPath;
use BSXPathKeys;
use BSDB;
use BSDBIndex;


use strict;

my $port = 5352;	#'SR'
$port = $1 if $BSConfig::srcserver =~ /:(\d+)$/;
my $ajaxsocket = "$BSConfig::bsdir/run/bs_srcserver.ajax";

my $projectsdir = "$BSConfig::bsdir/projects";
my $eventdir = "$BSConfig::bsdir/events";
my $srcrep = "$BSConfig::bsdir/sources";
my $requestsdir = "$BSConfig::bsdir/requests";

my $reqindexdb = "$BSConfig::bsdir/db/request";
my $extrepodb = "$BSConfig::bsdir/db/published";

my $remotecache = "$BSConfig::bsdir/remotecache";

my $srcrevlay = [qw{rev vrev srcmd5 version time user comment}];
my $eventlay = [qw{number time type project package repository arch}];

my %packagequota;

sub notify_repservers {
  my ($type, $projid, $packid) = @_;

  my $ev = {'type' => $type, 'project' => $projid};
  $ev->{'package'} = $packid if defined $packid;
  addevent($ev);

  my @args = ("type=$type", "project=$projid");
  push @args, "package=$packid" if defined $packid;
  for my $rrserver ($BSConfig::reposerver) {
    eval {
      BSRPC::rpc("$rrserver/event", undef, @args);
    };
    print "warning: $rrserver: $@" if $@;
  }
}

sub getrev {
  my ($projid, $packid, $rev) = @_;
  die("bad projid\n") if $projid =~ /\// || $projid =~ /^\./;
  return {'srcmd5' => 'pattern', 'rev' => 'pattern'} if $packid eq '_pattern';
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  if (! -e "$projectsdir/$projid.pkg/$packid.xml") {
    return remote_getrev($projid, $packid, $rev);
  }
  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');
  undef $rev if $rev && $rev eq 'upload' && ! -e "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS";
  if (!defined($rev)) {
    $rev = BSFileDB::fdb_getlast("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay);
    $rev = {'srcmd5' => 'empty'} unless $rev;
  } elsif ($rev =~ /^[0-9a-f]{32}$/) {
    return undef unless -e "$projectsdir/$projid.pkg/$packid.rev";
    $rev = {'srcmd5' => $rev, 'rev' => $rev};
  } elsif ($rev eq 'upload') {
    $rev = {'srcmd5' => 'upload', 'rev' => 'upload'}
  } elsif ($rev eq 'repository') {
    $rev = {'srcmd5' => 'empty', 'rev' => 'repository'}
  } else {
    $rev = BSFileDB::fdb_getmatch("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, 'rev', $rev);
  }
  $rev->{'srcmd5'} =~ s/\/.*// if $rev;		# XXX still needed?
  return $rev;
}

sub addmeta {
  my ($projid, $packid, $files, $rev) = @_;

  # calculate new meta sum
  my $meta = '';
  $meta .= "$files->{$_}  $_\n" for sort keys %$files;
  my $srcmd5 = Digest::MD5::md5_hex($meta);
  if ($rev && $rev eq 'upload') {
    mkdir_p("$srcrep/:upload");
    mkdir_p("$projectsdir/$projid.pkg");
    writestr("$srcrep/:upload/$$", "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS", $meta);
  } elsif ($rev && $rev eq 'pattern') {
    if ($meta ne '') {
      mkdir_p("$srcrep/:upload");
      mkdir_p("$projectsdir/$projid.pkg");
      writestr("$srcrep/:upload/$$", "$projectsdir/$projid.pkg/pattern-MD5SUMS", $meta);
    } else {
      unlink("$projectsdir/$projid.pkg/pattern-MD5SUMS");
    }
  } elsif (! -e "$srcrep/$packid/$srcmd5-MD5SUMS") {
    mkdir_p("$srcrep/:upload");
    mkdir_p("$srcrep/$packid");
    writestr("$srcrep/:upload/$$", "$srcrep/$packid/$srcmd5-MD5SUMS", $meta);
  }
  return $srcmd5;
}

sub addrev {
  my ($projid, $packid, $files, $user, $comment, $target) = @_;
  if ($packid eq '_pattern') {
    my $srcmd5 = addmeta($projid, $packid, $files, 'pattern');
    notify_repservers('project', $projid);

    return {'rev' => 'pattern', 'srcmd5' => $srcmd5};
  }
  if ($target && $target eq 'upload') {
    my $srcmd5 = addmeta($projid, $packid, $files, 'upload');
    my $filename = (keys %$files)[0];
    BSHermes::notify("SRCSRV_UPLOAD", {project => $projid, package => $packid, filename => $filename, comment => $comment, user => $user});
    return {'rev' => 'upload', 'srcmd5' => $srcmd5};
  } elsif ($target && $target eq 'repository') {
    # repository only upload.
    return {'rev' => 'repository'};
  } elsif (defined($target)) {
    # internal version only upload.
    my $srcmd5 = addmeta($projid, $packid, $files);
    return {'rev' => $srcmd5, 'srcmd5' => $srcmd5};
  }
  die("bad projid\n") if $projid =~ /\// || $projid =~ /^\./;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  die("bad files\n") if grep {/\//} keys %$files;
  die("bad files\n") if grep {!/^[0-9a-f]{32}$/} values %$files;

  # get version/release from rpm spec/deb dsc/kiwi xml file
  my $version = 'unknown';
  my $release;
  my $bconf = Build::read_config('noarch');
  for my $type ('spec', 'dsc', 'kiwi') {
    my $file = findfile($projid, $packid, undef, $type, $files);
    next unless defined $file;
    my $d = Build::parse($bconf, "$srcrep/$packid/$files->{$file}-$file");
    next unless defined $d->{'version'};
    $version = $d->{'version'};
    $release = $d->{'release'} if defined $d->{'release'};
    last;
  }
  if (defined($release) && $release =~ /^(\d+)/) {
    $release = $1;
  } else {
    $release = '0';
  }
  my $srcmd5 = addmeta($projid, $packid, $files);
  my $rev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'version' => $version, 'vrev' => $release};
  $rev = BSFileDB::fdb_add_i2("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay, $rev, 'vrev', 'version', $version);
  BSHermes::notify("SRCSRV_COMMIT", {project => $projid, package => $packid, files => $files, rev => $rev->{'rev'}, user => $user, comment => $comment});

  # kill upload revision as we did a real commit
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
  # XXX: Hermes?

  notify_repservers('package', $projid, $packid);
  return $rev;
}

sub lsrep {
  my ($projid, $packid, $srcmd5) = @_;
  die("no such revision\n") unless defined $srcmd5;
  local *F;
  die("bad packid\n") if $packid =~ /\// || $packid =~ /^\./;
  if ($srcmd5 eq 'upload') {
    open(F, '<', "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS") || die("$packid/$srcmd5-$packid: not in repository\n");
  } elsif ($srcmd5 eq 'pattern') {
    open(F, '<', "$projectsdir/$projid.pkg/pattern-MD5SUMS") || return {};
  } elsif ($srcmd5 eq 'empty') {
    return {};
  } else {
    die("bad srcmd5 '$srcmd5'\n") if $srcmd5 !~ /^[0-9a-f]{32}$/;
    if (!open(F, '<', "$srcrep/$packid/$srcmd5-MD5SUMS")) {
      return {'_linkerror' => $srcmd5} if -e "$srcrep/$packid/$srcmd5-_linkerror";
      die("$packid/$srcmd5-$packid: not in repository\n");
    };
  }
  my @files = <F>;
  close F;
  chomp @files;
  return {map {substr($_, 34) => substr($_, 0, 32)} @files};
}

sub patchspec {
  my ($p, $dir, $spec) = @_;
  local *F;
  open(F, '<', "$dir/$spec") || die("$dir/$spec: $!\n");
  my @preamble;
  while(<F>) {
    chomp;
    push @preamble, $_;
    last if /^\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\s|$)/;
  }
  my %patches;
  for (@preamble) {
    next unless /^patch(\d*)\s*:/i;  
    $patches{0 + ($1 eq '' ? 0 : $1)} = $_;
  }
  my @patches = sort {$a <=> $b} keys %patches;
  my $nr = 0;
  if (exists $p->{'after'}) {
    $nr = 0 + $p->{'after'};
    $nr++ while $patches{$nr};
  } else {
    $nr = $patches[-1] + 1 if @patches;
  }
  my @after;
  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;
  @after = grep {/^source(\d*)\s*:/i} @preamble if !@after;
  @after = grep {/^name(\d*)\s*:/i} @preamble if !@after;
  @after = $preamble[-2] if @preamble > 1 && !@after;
  return "could not find a place to insert the patch" if !@after;
  my $nrx = $nr;
  $nrx = '' if $nrx == 0;
  local *O;
  open(O, '>', "$dir/.patchspec$$") || die("$dir/.patchspec$$: $!\n");
  for (@preamble) {
    print O "$_\n";
    next unless @after && $_ eq $after[-1];
    print O "Patch$nrx: $p->{'name'}\n";
    @after = ();
  }
  if ($preamble[-1] !~ /^\s*%prep(\s|$)/) {
    while (1) {
      my $l = <F>;
      return "specfile has no %prep section" if !defined $l;
      chomp $l;
      print O "$l\n";
      last if $l =~ /^\s*%prep(\s|$)/;
    }
  }
  my @prep;
  while(<F>) {
    chomp;
    push @prep, $_;
    last if /^\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\s|$)/;
  }
  %patches = ();
  my $ln = -1;
  for (@prep) {
    $ln++;
    next unless /%patch(\d*)(.*)/;
    if ($1 ne '') {
      $patches{0 + $1} = $ln;
      next;
    }
    my @a = split(' ', $2);
    if (! grep {$_ eq '-P'} @a) {
      $patches{0} = $ln;
    } else {
      while (@a) {
        next if shift(@a) ne '-P';
        next if !@a || $a[0] !~ /^\d+$/;
        $patches{0 + shift(@a)} = $ln;
      }
    }
  }
  @patches = sort {$a <=> $b} keys %patches;
  $nr = 1 + $p->{'after'} if exists $p->{'after'};
  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;
  @after = ($patches[0] - 1) if !@after && @patches;
  @after = (@prep - 2) if !@after;
  my $after = $after[-1];
  $after = -1 if $after < -1;
  $ln = -1;
  push @prep, '' if $after >= @prep;
  #print "insert %patch after line $after\n";
  for (@prep) {
    if (defined($after) && $ln == $after) {
      print O "pushd $p->{'dir'}\n" if exists $p->{'dir'};
      if ($p->{'popt'}) {
        print O "%patch$nrx -p$p->{'popt'}\n";
      } else {
        print O "%patch$nrx\n";
      }
      print O "popd\n" if exists $p->{'dir'};
      undef $after;
    }
    print O "$_\n";
    $ln++;
  }
  while(<F>) {
    chomp;
    print O "$_\n";
  }
  close(O) || die("close: $!\n");
  rename("$dir/.patchspec$$", "$dir/$spec") || die("rename $dir/.patchspec$$ $dir/$spec: $!\n");
  return '';
}
# " Make emacs wired syntax highlighting happy

sub topaddspec {
  my ($p, $dir, $spec) = @_;
  local (*F, *O);
  open(F, '<', "$dir/$spec") || die("$dir/$spec: $!\n");
  open(O, '>', "$dir/.topaddspec$$") || die("$dir/.topaddspec$$: $!\n");
  my $text = $p->{'text'};
  $text = '' if !defined $text;
  $text .= "\n" if $text ne '' && substr($text, -1, 1) ne "\n";
  print O $text;
  while(<F>) {
    chomp;
    print O "$_\n";
  }
  close(O) || die("close: $!\n");
  rename("$dir/.topaddspec$$", "$dir/$spec") || die("rename $dir/.topaddspec$$ $dir/$spec: $!\n");
}

sub applylink {
  my ($md5, $lsrc, $llnk) = @_;

  if (-e "$srcrep/$llnk->{'package'}/$md5-_linkerror") {
    my $log = readstr("$srcrep/$llnk->{'package'}/$md5-_linkerror", 1);
    $log ||= "unknown error";
    chomp $log;
    $log =~ s/.*\n//s;
    $log ||= "unknown error";
    return $log;
  }
  my $flnk = lsrep($llnk->{'project'}, $llnk->{'package'}, $llnk->{'srcmd5'});
  die("applylink: $llnk->{'package'}/$llnk->{'srcmd5'}: nothing known\n") unless $flnk;
  my $fsrc = lsrep($lsrc->{'project'}, $lsrc->{'package'}, $lsrc->{'srcmd5'});
  die("applylink: $lsrc->{'package'}/$lsrc->{'srcmd5'}: nothing known\n") unless $fsrc;
  delete $fsrc->{'/LINK'};
  delete $fsrc->{'/LOCAL'};
  my $l = $llnk->{'link'};
  my $patches = $l->{'patches'} || {};
  my @patches = ();
  my $simple = 1;
  my @simple_delete;
  if ($l->{'patches'}) {
    for (@{$l->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if (!$type) {
	$simple = 0;
	next;
      }
      if ($type eq 'topadd') {
        push @patches, { 'type' => $type, 'text' => $_->{$type}};
	$simple = 0;
      } elsif ($type eq 'delete') {
        push @patches, { 'type' => $type, %{$_->{$type} || {}}};
	push @simple_delete, $patches[-1]->{'name'};
      } else {
        push @patches, { 'type' => $type, %{$_->{$type} || {}}};
	$simple = 0;
      }
    }
  }
  if ($simple) {
    # simple source link with no patching
    if ($lsrc->{'package'} ne $llnk->{'package'}) {
      # different packages, link needed sources
      for my $f (sort keys %$fsrc) {
        next if $flnk->{$f};
	next if -e "$srcrep/$llnk->{'package'}/$fsrc->{$f}-$f";
	link("$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f", "$srcrep/$llnk->{'package'}/$fsrc->{$f}-$f");
        die("link error $lsrc->{'package'}/$fsrc->{$f}-$f $llnk->{'package'}/$fsrc->{$f}-$f\n") unless -e "$srcrep/$llnk->{'package'}/$fsrc->{$f}-$f";
      }
    }
    # calculate meta
    my $newf = { %$fsrc };
    for my $f (sort keys %$flnk) {
      next if $f eq '_link';
      $newf->{$f} = $flnk->{$f};
    }
    delete $newf->{$_} for @simple_delete;
    # store filelist in md5
    my $meta = '';
    $meta .= "$newf->{$_}  $_\n" for sort keys %$newf;
    # add extra linked info
    $meta .= "$lsrc->{'srcmd5'}  /LINK\n";
    $meta .= "$llnk->{'srcmd5'}  /LOCAL\n";
    writestr("$srcrep/:upload/$$", "$srcrep/$llnk->{'package'}/$md5-MD5SUMS", $meta);
    return '';
  }

  # sanity checking...
  for my $p (@patches) {
    return "patch has no type" unless exists $p->{'type'};
    return "patch has illegal type \'$p->{'type'}\'" unless $p->{'type'} eq 'apply' || $p->{'type'} eq 'add' || $p->{'type'} eq 'topadd' || $p->{'type'} eq 'delete';
    if ($p->{'type'} ne 'topadd' && $p->{'type'} ne 'delete') {
      return "patch has no patchfile" unless exists $p->{'name'};
      return "patch \'$p->{'name'}\' does not exist" unless $flnk->{$p->{'name'}};
    }
  }
  my $tmpdir = "$srcrep/:upload/applylink$$";
  mkdir_p($tmpdir);
  die("$tmpdir: $!\n") unless -d $tmpdir;
  unlink("$tmpdir/$_") for ls($tmpdir);	# remove old stuff
  my %apply = map {$_->{'name'} => 1} grep {$_->{'type'} eq 'apply'} @patches;
  my %fl;
  for my $f (sort keys %$fsrc) {
    next if $flnk->{$f} && !$apply{$f};
    link("$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f", "$tmpdir/$f") || die("$f: $!\n");
    $fl{$f} = "$lsrc->{'package'}/$fsrc->{$f}-$f";
  }
  for my $f (sort keys %$flnk) {
    next if $apply{$f} || $f eq '_link';
    link("$srcrep/$llnk->{'package'}/$flnk->{$f}-$f", "$tmpdir/$f") || die("$f: $!\n");
    $fl{$f} = "$llnk->{'package'}/$flnk->{$f}-$f";
  }
  my $failed;
  for my $p (@patches) {
    my $pn = $p->{'name'};
    if ($p->{'type'} eq 'delete') {
      unlink("$tmpdir/$pn");
      next;
    }
    if ($p->{'type'} eq 'add') {
      for my $spec (grep {/\.spec$/} ls($tmpdir)) {
	local *F;
	open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	print F "adding patch $pn to $spec\n";
	close F;
        my $err = patchspec($p, $tmpdir, $spec);
        if ($err) {
	  open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	  print F "error: $err\n";
	  close F;
	  $failed = "could not add patch '$pn'";
	  last;
	  unlink("$tmpdir/$_") for ls($tmpdir);
	  rmdir($tmpdir);
	  return "could not add patch '$pn'";
	}
        delete $fl{$spec};
      }
      last if $failed;
      next;
    }
    if ($p->{'type'} eq 'topadd') {
      for my $spec (grep {/\.spec$/} ls($tmpdir)) {
	local *F;
	open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
	print F "adding text at top of $spec\n";
	close F;
        topaddspec($p, $tmpdir, $spec);
        delete $fl{$spec};
      }
      next;
    }
    next unless $p->{'type'} eq 'apply';
    my $pid;
    if (!($pid = xfork())) {
      delete $SIG{'__DIE__'};
      chdir($tmpdir) || die("$tmpdir: $!\n");
      open(STDIN, '<', "$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn") || die("$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn: $!\n");
      open(STDOUT, '>>', ".log") || die(".log: $!\n");
      open(STDERR, '>&STDOUT');
      $| = 1;
      print "applying patch $pn\n";
      $::ENV{'TMPDIR'} = '.';
      exec('/usr/bin/patch', '--no-backup-if-mismatch', '--unified-reject-files', '--global-reject-file=.rejects', '-g', '0', '-f');
      die("/usr/bin/patch: $!\n");
    }
    waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
    my $patchstatus = $?;
    if ($patchstatus) {
      $failed = "could not apply patch '$pn'";
      last;
    }
  }
  if ($failed) {
    local *F;
    # add result as last line
    open(F, '>>', "$tmpdir/.log") || die("$tmpdir/.log: $!\n");
    print F "\n$failed\n";
    close F;
    # link error marker
    if (!link("$tmpdir/.log", "$srcrep/$llnk->{'package'}/$md5-_linkerror")) {
      my $err = "link $tmpdir/.log $srcrep/$llnk->{'package'}/$md5-_linkerror: $!\n";
      die($err) unless -e "$srcrep/$llnk->{'package'}/$md5-_linkerror";
    }
    unlink("$tmpdir/$_") for ls($tmpdir);
    rmdir($tmpdir);
    return $failed;
  }
  my @newf = grep {!/^\./} ls($tmpdir);
  my $newf = {};
  local *F;
  for my $f (@newf) {
    my @s = stat "$tmpdir/$f";
    die("$tmpdir/$f: $!\n") unless @s;
    if ($s[3] > 1 && $fl{$f}) {
      my @s2 = stat "$srcrep/$fl{$f}";
      die("$srcrep/$fl{$f}: $!\n") unless @s2;
      if ("$s[0]/$s[1]" eq "$s2[0]/$s2[1]") {
        $newf->{$f} = $fl{$f};
        $newf->{$f} =~ s/.*\///;
        $newf->{$f} = substr($newf->{$f}, 0, 32);
	next;
      }
    }
    open(F, '<', "$tmpdir/$f") || die("$tmpdir/$f: $!\n");
    my $ctx = Digest::MD5->new;
    $ctx->addfile(*F);
    close F;
    $newf->{$f} = $ctx->hexdigest();
  }
  # now link everything over
  for my $f (@newf) {
    next if -e "$srcrep/$llnk->{'package'}/$newf->{$f}-$f";
    link("$tmpdir/$f", "$srcrep/$llnk->{'package'}/$newf->{$f}-$f");
    die("link error") unless -e "$srcrep/$llnk->{'package'}/$newf->{$f}-$f";
  }
  # clean up tmpdir
  unlink("$tmpdir/$_") for ls($tmpdir);
  rmdir($tmpdir);
  # store filelist in md5
  my $meta = '';
  $meta .= "$newf->{$_}  $_\n" for sort keys %$newf;
  # add extra linked info
  $meta .= "$lsrc->{'srcmd5'}  /LINK\n";
  $meta .= "$llnk->{'srcmd5'}  /LOCAL\n";
  mkdir_p("$srcrep/:upload");
  writestr("$srcrep/:upload/$$", "$srcrep/$llnk->{'package'}/$md5-MD5SUMS", $meta);
  return '';
}

sub handlelinks {
  my ($projid, $pinfo, $files, $rev) = @_;
  my @linkinfo;
  my %seen;
  my $packid = $pinfo->{'name'};
  push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $pinfo->{'srcmd5'}, 'rev' => $pinfo->{'rev'}};
  delete $pinfo->{'srcmd5'};
  my $vrev = $rev ? $rev->{'vrev'} : 0;
  my $vrevdone = $rev ? 0 : 1;
  while ($files->{'_link'}) {
    my $l = readxml("$srcrep/$packid/$files->{'_link'}-_link", $BSXML::link, 1);
    return '_link is bad' unless $l;
    eval {
      BSVerify::verify_link($l);
    };
    if ($@) {
      my $err = $@;
      $err =~ s/\n$//s;
      return "_link is bad: $err";
    }
    $l->{'project'} = $linkinfo[-1]->{'project'} unless exists $l->{'project'};
    $l->{'package'} = $linkinfo[-1]->{'package'} unless exists $l->{'package'};
    $linkinfo[-1]->{'link'} = $l;
    $projid = $l->{'project'};
    $packid = $l->{'package'};
    my $lrev = $l->{'rev'} || '';
    return 'circular package link' if $seen{"$projid/$packid/$lrev"};
    $seen{"$projid/$packid/$lrev"} = 1;
    # record link target for projpack
    push @{$pinfo->{'linked'}}, {'project' => $projid, 'package' => $packid};
    eval {
      $lrev = getrev($projid, $packid, $l->{'rev'});
    };
    if ($@) {
      my $error = $@;
      $error =~ s/\n$//s;
      return "$projid $packid: $error";
    }
    return "linked package '$packid' does not exist in project '$projid'" unless $lrev;
    $files = lsrep($projid, $packid, $lrev->{'srcmd5'});
    return 'linked package is not in repository' unless $files;
    my $cicount = $l->{'cicount'} || 'add';
    if ($cicount eq 'copy') {
      $rev->{'vrev'} -= $vrev unless $vrevdone;
    } elsif ($cicount eq 'local') {
      $vrevdone = 1;
    } elsif ($cicount ne 'add') {
      return '_link is bad: illegal cicount';
    }
    $vrev = $lrev->{'vrev'};
    $rev->{'vrev'} += $vrev unless $vrevdone;
    push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $lrev->{'srcmd5'}, 'rev' => $lrev->{'rev'}};
  }
  my $md5;
  my $oldl;
  for my $l (reverse @linkinfo) {
    if (!$md5) {
      $md5 = $l->{'srcmd5'};
      $oldl = $l;
      next;
    }
    my $md5c = "$md5  /LINK\n$l->{'srcmd5'}  /LOCAL\n";
    $md5 = Digest::MD5::md5_hex($md5c);
    if (! -e "$srcrep/$l->{'package'}/$md5-MD5SUMS") {
      my $error = applylink($md5, $oldl, $l);
      if ($error) {
        $pinfo->{'srcmd5'} = $md5 if $l == $linkinfo[0];
        return $error;
      }
    }
    $l->{'srcmd5'} = $md5;
    $oldl = $l;
  }
  # add extra info to pinfo
  $projid = $linkinfo[0]->{'project'};
  $packid = $linkinfo[0]->{'package'};
  shift @linkinfo;
  $pinfo->{'srcmd5'} = $md5;
  $files = lsrep($projid, $packid, $md5);
  my $meta = '';
  for (sort keys %$files) {
    $meta .= "$files->{$_}  $_\n" if $_ ne '/LINK' && $_ ne '/LOCAL';
  }
  $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);
  $pinfo->{'vrev'} = $rev->{'vrev'} if $rev && defined $rev->{'vrev'};
  return $files;
}

sub findprojects {
  local *D;
  opendir(D, $projectsdir) || die("$projectsdir: $!\n");
  my @projids = grep {s/\.xml$//} readdir(D);
  closedir(D);
  return sort @projids;
}

sub findpackages {
  my ($projid) = shift;
  opendir(D, "$projectsdir/$projid.pkg") || return ();
  my @packids = grep {s/\.xml$//} readdir(D);
  closedir(D);
  return sort @packids;
}

sub readproj {
  my ($projid, $nonfatal) = @_;
  my $proj = readxml("$projectsdir/$projid.xml", $BSXML::proj, 1);
  die("project '$projid' does not exist\n") if !$proj && !$nonfatal;
  return $proj;
}

sub readpack {
  my ($projid, $packid, $nonfatal) = @_;
  my $pack = readxml("$projectsdir/$projid.pkg/$packid.xml", $BSXML::pack, 1);
  if (!$pack && !$nonfatal) {
    readproj($projid);
    die("package '$packid' does not exist in project '$projid'\n");
  }
  return $pack;
}

# find matching .spec/.dsc/.kiwi file depending on packid and/or repoid
sub findfile {
  my ($projid, $packid, $repoid, $ext, $files) = @_;
  $files = lsrep($projid, $packid, $files) unless ref $files;
  return ($files->{"$packid-$repoid.$ext"}, "$packid-$repoid.$ext") if defined($repoid) && $files->{"$packid-$repoid.$ext"};
  return ($files->{"$packid.$ext"}, "$packid.$ext") if $files->{"$packid.$ext"} && defined($repoid);
  my @files = grep {/\.$ext$/} keys %$files;
  @files = grep {/^\Q$packid\E/i} @files if @files > 1;
  return ($files->{$files[0]}, $files[0]) if @files == 1;
  if (@files > 1) {
    if (!defined($repoid)) {
      # return (undef, undef);
      @files = sort @files;
      return ($files->{$files[0]}, $files[0]);
    }
    @files = grep {/^\Q$packid-$repoid\E/i} @files if @files > 1;
    return ($files->{$files[0]}, $files[0]) if @files == 1;
  }
  return (undef, undef);
}

sub getkiwipackages {
  my ($md5, $file, $proj, $packid, $arch, $count) = @_;

  # Endless recursion is possible, so we fail after 10 !
  $count ||= 0;
  return "Kiwi config inclusion depth limit reached (10) !" if $count++ > 10;

  my @alltypes = ();
  my @allrepos = ();
  my @allpackages = ();
  my $kiwidesc = readxml("$srcrep/$packid/$md5-$file", $BSXML::kiwidesc, 1);
  return ("bad kiwi description data") unless $kiwidesc;

  for my $type (@{$kiwidesc->{'preferences'}->{'type'} || []}) {
    push @alltypes, $type->{'_content'};

    # Parse included kiwi configs
    if (defined $type->{'boot'}) {
      if ($type->{'boot'} =~ /^obs:\/\/(.+)$/ ) {
        my @s = split('/', $1, 2);
        my $subproject = $s[0];
        my $subpackage = $s[1];
        my $rev = getrev($subproject, $subpackage);
	if (!$rev || $rev->{'srcmd5'} eq 'empty') {
	  return ("Refered to non existing kiwi config in $proj $packid to $subproject $subpackage");
	}
        my $files = lsrep($subproject, $subpackage, $rev->{'srcmd5'});
# FIXME: handle source links
#        $files = handlelinks($projid, $pinfo, $files, $rev) if ref($files) && $files->{'_link'};
        if (!ref $files) {
          return ("could not get file list for $subproject $subpackage");
        }
        my ($submd5, $subfile) = findfile($subproject, $subpackage, undef, 'kiwi', $files);
        if ($submd5 && $subfile) {
          my ($error, $kiwirepos, $kiwipackages, $kiwitypes) = getkiwipackages($submd5, $subfile, $subproject, $subpackage, $arch);
          @allrepos= @{$kiwirepos};
          @allpackages= @{$kiwipackages};
          # skip kiwitypes, we only build the ones from the origin file.
        } else {
          return ("refered KIWI config not found $subproject $subpackage");
        }
      } else {
        return ("non OBS kiwi image description refered in $proj $packid $file");
      }
    }
  }

  # collect all possible needed repositories
  # this should maybe moved above to the expandrepos calls without harming performance
  for my $repository (@{$kiwidesc->{'repository'} || []}) {
    for my $kiwisource (@{$repository->{'source'} || []}) {
      if ($kiwisource->{'path'} =~ /^obs:\/\/(.+)$/) {
        my @s = split('/', $1, 2);
        # Project in remote build service instance ?
# FIXME: handle remote projects
#        if ($withremotemap && !exists($remotemap{$s[0]})) {
#          $remotemap{$s[0]} = remoteprojid($s[0]);
#        }
        my $prp = {'project' => $s[0], 'repository' => $s[1]};
        push @allrepos, $prp;
      } else {
        return ("non Build Service KIWI source found: $kiwisource->{'path'}");
      }
    }
  }

  # collect all package requires from all packages groups.
  for my $packagegroup (@{$kiwidesc->{'packages'} || []}) {
    for my $package (@{$packagegroup->{'package'} || []}) {
        # FIXME: add check if arch is specified !
        push @allpackages, $package->{'name'};
    }
    # FIXME: add support for patterns
  }

  # Add implicit the package manager package
  my $packman = $kiwidesc->{'preferences'}->{'packagemanager'};
  if ($packman eq "smart") { 
    push @allpackages, "smart";
  } elsif ($packman eq "zypper") { 
    push @allpackages, "zypper";
  } else {
    return ("unknown package manager: $packman");
  }
  my %allpackages = map {$_ => 1} @allpackages;
  @allpackages = sort keys %allpackages;
  return (undef, \@allrepos, \@allpackages, \@alltypes);
}

sub getprojquotapackage {
  my ($projid) = @_;
  if (!exists($packagequota{':packages'})) {
    my $quotaxml = readxml($BSConfig::bsquotafile, $BSXML::quota, 1);
    for my $p (@{$quotaxml->{'project'} || []}) {
      $packagequota{$p->{'name'}} = $p->{'packages'};
    }
    $packagequota{':packages'} = $quotaxml->{'packages'};
  }
  while ($projid) {
    return $packagequota{$projid} if exists $packagequota{$projid};
    last unless $projid =~ s/:[^:]*$//;
  }
  return $packagequota{':packages'};
}

sub getprojpack {
  my ($cgi, $projids, $repoids, $packids, $arch) = @_;
  $arch ||= 'noarch';
  $projids = [ findprojects() ] unless $projids;
  if ($BSConfig::limit_projects && $BSConfig::limit_projects->{$arch}) {
    $projids ||= $BSConfig::limit_projects->{$arch};
    my %limit_projids = map {$_ => 1} @{$BSConfig::limit_projects->{$arch}};
    $projids = [ grep {$limit_projids{$_}} @$projids ];
  }
  $repoids = { map {$_ => 1} @$repoids } if $repoids;
  $packids = { map {$_ => 1} @$packids } if $packids;
  my $bconf = Build::read_config($arch);

  my %remotemap;
  my $withremotemap = $cgi->{'withremotemap'};
  my @res;
  for my $projid (@$projids) {
    my $jinfo = { 'name' => $projid };
    my $proj = readproj($projid, 1);
    next unless $proj;
    if ($withremotemap && !exists($remotemap{$projid})) {
      $remotemap{$projid} = remoteprojid($projid);
    }
    if ($cgi->{'withconfig'}) {
      my $config = readstr("$projectsdir/$projid.conf", 1);
      if ($config) {
	# strip away macro blocks
	while ($config =~ /^(.*?\n)?\s*(macros:[^\n]*\n.*)/si) {
	  my ($c1, $c2) = ($1, $2);
	  $c1 = '' unless defined $c1;
	  if ($c2 =~ /^(?:.*?\n)?\s*:macros\s*\n(.*)$/si) {
	    $config = "$c1$c2";
	  } else {
	    $config = $c1;
	    last;
	  }
	}
	$jinfo->{'config'} = $config unless $config =~ /^\s*$/s;
      }
    }
    if ($cgi->{'withsrcmd5'} && -s "$projectsdir/$projid.pkg/pattern-MD5SUMS") {
      my $patterns = readstr("$projectsdir/$projid.pkg/pattern-MD5SUMS", 1);
      $jinfo->{'patternmd5'} = Digest::MD5::md5_hex($patterns) if $patterns;
    }
    my @packages;
    @packages = findpackages($projid) unless $cgi->{'nopackages'};
    next if $repoids && !grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []};
    next if $packids && !grep {$packids->{$_}} @packages;
    for (qw{title description build publish debuginfo useforbuild remoteurl remoteproject}) {
      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};
    }
    # Check build flags in project meta data
    my $pdisabled;
    if ($jinfo->{'build'} && !$cgi->{'ignoredisable'}) {
      $pdisabled = 1 if grep {!exists($_->{'repository'}) && (!exists($_->{'arch'}) || $_->{'arch'} eq $arch)} @{$jinfo->{'build'}->{'disable'} || []};
      undef $pdisabled if $pdisabled && grep {!exists($_->{'repository'}) && (!exists($_->{'arch'}) || $_->{'arch'} eq $arch)} @{$jinfo->{'build'}->{'enable'} || []};
    }

    # Check package number quota
    my $quota_exceeded;
    if ($BSConfig::bsquotafile) {
      my $pquota = getprojquotapackage($projid);
      $quota_exceeded = 1 if defined($pquota) && @packages > $pquota;
    }

    if ($cgi->{'withrepos'}) {
      if ($repoids) {
	$jinfo->{'repository'} = [ grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []} ];
      } else {
        $jinfo->{'repository'} = $proj->{'repository'} || [];
      }
      if ($cgi->{'expandedrepos'}) {
	for my $repo (@{$jinfo->{'repository'}}) {
	  my @prps = expandsearchpath($projid, $repo->{'name'});
	  for my $prp (@prps) {
	    my @s = split('/', $prp, 2);
	    if ($withremotemap && !exists($remotemap{$s[0]})) {
	      $remotemap{$s[0]} = remoteprojid($s[0]);
	    }
	    $prp = {'project' => $s[0], 'repository' => $s[1]};
	  }
	  $repo->{'path'} = \@prps;
	}
      }
    }
    if (!grep {!$_->{'status'} || $_->{'status'} ne 'disabled'} @{$proj->{'repository'} || []}) {
      # either no repositories or all disabled. No need to check packages
      @packages = ();
    }
    @packages = () if $cgi->{'nopackages'};
    my @pinfo;
    my %bconfs;

    for my $packid (@packages) {

      next if $packids && !$packids->{$packid};
      my $pinfo = {'name' => $packid};
      push @pinfo, $pinfo;
      my $pack = readpack($projid, $packid, 1);
      if (!$pack) {
	$pinfo->{'error'} = 'no metadata';
	next;
      }
      for (qw{build publish debuginfo useforbuild}) {
	$pinfo->{$_} = $pack->{$_} if $pack->{$_};
      }
      if (!$pinfo->{'build'}) {
        $pinfo->{'build'}->{'enable'} = $pack->{'enable'} if $pack->{'enable'};
        $pinfo->{'build'}->{'disable'} = $pack->{'disable'} if $pack->{'disable'};
      }
      my $disable = {};
      my $enable = {};
      undef($enable) if $cgi->{'ignoredisable'};
      if ($enable && $pinfo->{'build'} && $pinfo->{'build'}->{'enable'}) {
	for (grep {!exists($_->{'arch'}) || $_->{'arch'} eq $arch} @{$pack->{'enable'}}) {
	  undef($enable), last unless exists $_->{'repository'};
	  $enable->{$_->{'repository'}} = 1;
        }
      }
      if ($enable) {
	if ($pinfo->{'build'} && $pinfo->{'build'}->{'disable'}) {
	  for (grep {!exists($_->{'arch'}) || $_->{'arch'} eq $arch} @{$pack->{'disable'}}) {
	    undef($disable), last unless exists $_->{'repository'};
	    $disable->{$_->{'repository'}} = 1;
	  }
	}
      }
      if ((!$disable || $pdisabled) && $enable && !%$enable) {
	$pinfo->{'error'} = 'disabled';
	next;
      }
      if ($quota_exceeded) {
	$pinfo->{'error'} = 'quota exceeded';
	next;
      }
      if ($cgi->{'withsrcmd5'} || $cgi->{'withdeps'}) {
        my $rev = getrev($projid, $packid, 'build');
	if (!$rev || $rev->{'srcmd5'} eq 'empty') {
	  $pinfo->{'error'} = 'no source uploaded';
	  next;
	}
	$pinfo->{'srcmd5'} = $rev->{'srcmd5'};
	$pinfo->{'rev'} = $rev->{'rev'};
	my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
	$files = handlelinks($projid, $pinfo, $files, $rev) if ref($files) && $files->{'_link'};
	if (!ref $files) {
	  $pinfo->{'error'} = defined($files) ? $files : "could not get file list";
	  next;
	}
        delete $pinfo->{'vrev'};

	if ($files->{'_aggregate'}) {
	  my $aggregatelist = readxml("$srcrep/$packid/$files->{'_aggregate'}-_aggregate", $BSXML::aggregatelist, 1);
	  if (!$aggregatelist) {
	    $pinfo->{'error'} = "bad aggregatelist data";
	    next;
	  }
          eval {
	    BSVerify::verify_aggregatelist($aggregatelist);
          };
	  if ($@) {
	    my $err = $@;
	    $err =~ s/\n$//s;
	    $pinfo->{'error'} = "bad aggregatelist: $err";
	    next;
	  }
	  $pinfo->{'aggregatelist'} = $aggregatelist;
	  if (($enable && %$enable) || ($disable && %$disable)) {
	    my @dinfo = ();
	    for my $repo (@{$proj->{'repository'} || []}) {
	      my $repoid = $repo->{'name'};
	      next if $repoids && !$repoids->{$repoid};
	      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};
		next;
	      }
	    }
	    $pinfo->{'info'} = \@dinfo if @dinfo;
	  }
        } elsif ($cgi->{'withdeps'}) {
	  my @dinfo = ();

          # Build config cache for all repositories
	  for my $repo (@{$proj->{'repository'} || []}) {
	    my $repoid = $repo->{'name'};
	    next if $repoids && !$repoids->{$repoid};

	    if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {
	      push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};
	      next;
	    }
            if (!$bconfs{$repoid}) {
	      print "reading config for $projid/$repoid $arch\n";
	      my $c;
	      eval {
	        ($c) = getconfig($cgi, $projid, $repoid);
	      };
	      if ($@) {
	        my $err = $@;
	        $err =~ s/\n$//;
	        push @dinfo, {'repository' => $repoid, 'error' => $err};
	        next;
	      }
	      $c = [ split("\n", $c) ];
	      $bconfs{$repoid} = Build::read_config($arch, $c);
            };
	    my $conf = $bconfs{$repoid};

	    my $type = $conf->{'type'} || 'spec';
            my ($md5, $file) = findfile($projid, $packid, $repoid, $type, $files);
	    if (!$md5) {
		# no spec/dsc/kiwi file found
		if (grep {/\.(?:spec|dsc|kiwi)$/} keys %$files) {
		    # only different types available
		    push @dinfo, {'repository' => $repoid, 'error' => 'excluded'};
		} else {
		    push @dinfo, {'repository' => $repoid };
		}
		next;
	    }
	    if ($type eq 'kiwi' && $BSConfig::kiwiprojects) {
	      my %kiwiprojects = map {$_ => 1} @$BSConfig::kiwiprojects;
	      if (!$kiwiprojects{$projid}) {
		push @dinfo, {'repository' => $repoid, 'error' => 'kiwi image building is not enabled for this project'};
		next;
	      }
	    }
	    if ($type eq 'kiwi') {
	      my ($error, $kiwirepos, $kiwipackages, $kiwitypes) = getkiwipackages($md5, $file, $projid, $packid, $arch);
	      if (defined $error) {
		push @dinfo, {'repository' => $repoid, 'error' => $error};
		next;
	      }
	      push @dinfo, {'repository' => $repoid, 'file' => $file, 'name' => $packid,
			    'dep' => \@{$kiwipackages}, 'imagetype' => \@{$kiwitypes}, 'path' => $kiwirepos};
	      next;
	    }
	    # get build dependency info
            my $d = Build::parse($conf, "$srcrep/$packid/$md5-$file");
            if (defined($d->{'name'})) {
	      my $version = defined($d->{'version'}) ? $d->{'version'} : 'unknown';
	      $pinfo->{'versrel'} ||= "$version-$rev->{'vrev'}";
	      if ($d->{'prereqs'}) {
	        push @dinfo, {'repository' => "$repoid", 'file' => $file, 'name' => $d->{'name'}, 'dep' => $d->{'deps'}, 'supportdeps' => $d->{'prereqs'}};
              } else {
	        push @dinfo, {'repository' => "$repoid", 'file' => $file, 'name' => $d->{'name'}, 'dep' => $d->{'deps'}};
              };
	      $dinfo[-1]->{'error'} = 'excluded' if $d->{'exclarch'} && !grep {$_ eq $arch} @{$d->{'exclarch'}};
	    } else {
	      push @dinfo, {'repository' => "$repoid", 'file' => $file, 'error' => "file parse error"};
	    }
	  }
	  $pinfo->{'info'} = \@dinfo if @dinfo;
	}
      }
    }
    $jinfo->{'package'} = \@pinfo;
    push @res, $jinfo;
  }
  my $ret = {'project' => \@res};
  if ($withremotemap && %remotemap) {
    for (sort keys %remotemap) {
      next unless $remotemap{$_};
      my $r = {'project' => $_, 'remoteurl' => $remotemap{$_}->{'remoteurl'}, 'remoteproject' => $remotemap{$_}->{'remoteproject'}};
      push @{$ret->{'remotemap'}}, $r;
    }
  }
  return ($ret, $BSXML::projpack);
}

sub getprojectlist {
  my ($cgi) = @_;
  my @projects = findprojects();
  @projects = map {{'name' => $_}} @projects;
  return ({'entry' => \@projects}, $BSXML::dir);
}

sub getproject {
  my ($cgi, $projid) = @_;
  # Read the project xml file
  my $proj = readproj($projid);

  # return project meta data
  return ($proj, $BSXML::proj);
}

sub createkey {
  my ($cgi, $projid) = @_;
  die("don't know how to create a key\n") unless $BSConfig::sign;
  die("project $projid does not exist\n") unless -s "$projectsdir/$projid.xml";
  mkdir_p("$srcrep/:upload");
  local *F;
  my $pubkey = '';
  my @keyargs = ('dsa@1024', '800');
  open(F, '-|', $BSConfig::sign, '-P', "$srcrep/:upload/signkey.$$", '-g', @keyargs , "$projid OBS Project", "$projid\@build.opensuse.org") || die("$BSConfig::sign: $!\n");
  1 while sysread(F, $pubkey, 4096, length($pubkey));
  close(F) || die("$BSConfig::sign: $?\n");
  die("sign did not create signkey\n") unless -s "$srcrep/:upload/signkey.$$";
  mkdir_p("$projectsdir/$projid.pkg");
  writestr("$srcrep/:upload/pubkey.$$", "$projectsdir/$projid.pkg/_pubkey", $pubkey);
  if (!rename("$srcrep/:upload/signkey.$$", "$projectsdir/$projid.pkg/_signkey")) {
    unlink("$projectsdir/$projid/_pubkey");
    die("rename $srcrep/:upload/signkey.$$ $projectsdir/$projid.pkg/_signkey: $!\n");
  }
  return $BSStdServer::return_ok;
}

sub deletekey {
  my ($cgi, $projid) = @_;
  if ($BSConfig::forceprojectkeys) {
    my $pprojid = $projid;
    $pprojid =~ s/:[^:]*$//;
    my $sk;
    ($sk) = getsignkey({}, $pprojid) if $projid ne $pprojid;
    die("must have a key for signing\n") unless $sk;
  }
  unlink("$projectsdir/$projid.pkg/_signkey");
  unlink("$projectsdir/$projid.pkg/_pubkey");
  rmdir("$projectsdir/$projid.pkg");
  return $BSStdServer::return_ok;
}

sub getpubkey {
  my ($cgi, $projid) = @_;
  my $pubkey = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
  die("$projid: no pubkey available\n") unless $pubkey;
  return ($pubkey, 'Content-Type: text/plain');
}

sub projectcmd {
  my ($cgi, $projid) = @_;
  my $cmd = $cgi->{'cmd'};
  return createkey($cgi, $projid) if $cmd eq 'createkey';
  die("unknown command '$cmd'\n");
}

sub putproject {
  my ($cgi, $projid) = @_;
  mkdir_p("$srcrep/:upload");
  my $uploaded = BSServer::read_file("$srcrep/:upload/$$");
  die("upload failed\n") unless $uploaded;
  my $proj = readxml("$srcrep/:upload/$$", $BSXML::proj);
  BSVerify::verify_proj($proj, $projid);
  writexml("$srcrep/:upload/$$.2", undef, $proj, $BSXML::proj);
  unlink("$srcrep/:upload/$$");
  rename("$srcrep/:upload/$$.2", "$projectsdir/$projid.xml") || die("rename to $projectsdir/$projid.xml: $!\n");
  if ($BSConfig::forceprojectkeys) {
    my ($sk) = getsignkey({}, $projid);
    createkey({}, $projid) if $sk eq '';
  }
  notify_repservers('project', $projid);
  BSHermes::notify("SRCSRV_UPDATE_PROJECT", { "project" => $projid });

  $proj = readproj($projid);
  return ($proj, $BSXML::proj);
}

sub delproject {
  my ($cgi, $projid) = @_;

  die("project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  if (-d "$projectsdir/$projid.pkg") {
    # delete those packages and keys
    for my $f (ls("$projectsdir/$projid.pkg")) {
      unlink("$projectsdir/$projid.pkg/$f");
    }
    rmdir("$projectsdir/$projid.pkg") || die("rmdir $projectsdir/$projid.pkg: $!\n");
  }
  unlink("$projectsdir/$projid.conf");
  unlink("$projectsdir/$projid.xml");
  notify_repservers('project', $projid);

  BSHermes::notify("SRCSRV_DELETE_PROJECT", { "project" => $projid });

  return $BSStdServer::return_ok;
}

##########################################################################

sub getpackagelist {
  my ($cgi, $projid, $repoid, $arch) = @_;
  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);
  if ($proj->{'remoteurl'}) {
    return BSRPC::rpc("$proj->{'remoteurl'}/source/$proj->{'remoteproject'}", $BSXML::dir), $BSXML::dir;
  }
  my @packages = findpackages($projid);
  my @plist = map {{'name' => $_}} @packages;
  return ({'entry' => \@plist}, $BSXML::dir);
}

sub getpackage {
  my ($cgi, $projid, $packid) = @_;
  my $pack = readpack($projid, $packid);
  return ($pack, $BSXML::pack);
}

sub putpackage {
  my ($cgi, $projid, $packid) = @_;
  mkdir_p("$srcrep/:upload");
  my $uploaded = BSServer::read_file("$srcrep/:upload/$$");
  die("upload failed\n") unless $uploaded;
  my $pack = readxml("$srcrep/:upload/$$", $BSXML::pack);
  BSVerify::verify_pack($pack, $packid);
  die("package contains revision data\n") if grep {exists $pack->{$_}} @$srcrevlay;
  # XXX
  # delete rev stuff, just in case...
  # delete $pack->{$_} for @$srcrevlay;
  # $pack->{'name'} = $packid;
  writexml("$srcrep/:upload/$$.2", undef, $pack, $BSXML::pack);
  unlink("$srcrep/:upload/$$");
  my $proj = readproj($projid);
  mkdir_p("$projectsdir/$projid.pkg");
  rename("$srcrep/:upload/$$.2", "$projectsdir/$projid.pkg/$packid.xml") || die("rename to $projectsdir/$projid.pkg/$packid.xml: $!\n");
#  my %packages = map {$_->{'name'} => 1} @{$proj->{'package'} || []};
#  if (!$packages{$packid}) {
#    # a new package! add id to project data
#    push @{$proj->{'package'}}, {'name' => $packid};
#    writexml("$srcrep/:upload/$$.3", "$projectsdir/$projid.xml", $proj, $BSXML::proj);
#  }
  notify_repservers('package', $projid, $packid);
  $pack = readpack($projid, $packid);
  return ($pack, $BSXML::pack);
}

sub delpackage {
  my ($cgi, $projid, $packid) = @_;
  die("project '$projid' does not exist\n") unless -e "$projectsdir/$projid.xml";
  die("package '$packid' does not exist in project '$projid'\n") unless -e "$projectsdir/$projid.pkg/$packid.xml";
  unlink("$projectsdir/$projid.pkg/$packid.upload-MD5SUMS");
  unlink("$projectsdir/$projid.pkg/$packid.rev");
  unlink("$projectsdir/$projid.pkg/$packid.xml");
  notify_repservers('package', $projid, $packid);
  BSHermes::notify("SRCSRV_DELETE_PACKAGE", { "project" => $projid, "package" => $packid });

  return $BSStdServer::return_ok;
}

sub getpackagehistory {
  my ($cgi, $projid, $packid) = @_;
  my @res;
  for (BSFileDB::fdb_getall("$projectsdir/$projid.pkg/$packid.rev", $srcrevlay)) {
    push @res, $_;
  }
  return ({'revision' => \@res}, $BSXML::revisionlist);
}

##########################################################################

##########################################################################

# XXX -> library

sub remoteprojid {
  my ($projid) = @_;
  my $rsuf = '';
  my $origprojid = $projid;

  my $proj = readproj($projid, 1);
  if ($proj) {
    return undef unless $proj->{'remoteurl'};
    return undef unless $proj->{'remoteproject'};
    return {
      'name' => $projid,
      'root' => $projid,
      'remoteroot' => $proj->{'remoteproject'},
      'remoteurl' => $proj->{'remoteurl'},
      'remoteproject' => $proj->{'remoteproject'},
    };
  }
  while ($projid =~ /^(.*)(:.*?)$/) {
    $projid = $1;
    $rsuf = "$2$rsuf";
    $proj = readproj($projid, 1);
    if ($proj) {
      return undef unless $proj->{'remoteurl'};
      if ($proj->{'remoteproject'}) {
        $rsuf = "$proj->{'remoteproject'}$rsuf";
      } else {
        $rsuf =~ s/^://;
      }
      return {
        'name' => $origprojid,
        'root' => $projid,
        'remoteroot' => $proj->{'remoteproject'},
        'remoteurl' => $proj->{'remoteurl'},
        'remoteproject' => $rsuf,
      };
    }
  }
  return undef;
}

sub maptoremote {
  my ($proj, $projid) = @_;
  return "$proj->{'root'}:$projid" unless $proj->{'remoteroot'};
  return $proj->{'root'} if $projid eq $proj->{'remoteroot'};
  return '_unavailable' if $projid !~ /^\Q$proj->{'remoteroot'}\E:(.*)$/;
  return "$proj->{'root'}:$1";
}

sub fetchremoteproj {
  my ($proj, $projid) = @_;
  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};
  $projid ||= $proj->{'name'};
  print "fetching remote project data for $projid\n";
  my $param = {
    'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta",
    'timeout' => 60,
  };
  my $rproj = BSRPC::rpc($param, $BSXML::proj);
  return undef unless $rproj;
  for (qw{name root remoteroot remoteurl remoteproject}) {
    $rproj->{$_} = $proj->{$_};
  }
  return $rproj;
}

sub fetchremoteconfig {
  my ($proj, $projid) = @_;
  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};
  $projid ||= $proj->{'name'};
  print "fetching remote project config for $projid\n";
  my $param = {
    'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config",
    'timeout' => 60,
  };
  return BSRPC::rpc($param, undef);
}

sub remote_getrev {
  my ($projid, $packid, $rev) = @_;
  my $proj = remoteprojid($projid);
  return undef unless $proj;
  my @args;
  push @args, "expand";
  push @args, "rev=$rev" if defined $rev;
  my $dir = BSRPC::rpc("$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid", $BSXML::dir, @args);
  die("$dir->{'error'}\n") if $dir->{'error'};
  $rev = {};
  $rev->{'rev'} = $dir->{'rev'} || $dir->{'srcmd5'};
  $rev->{'srcmd5'} = $dir->{'srcmd5'};
  $rev->{'vrev'} = $dir->{'vrev'};
  $rev->{'vrev'} ||= '0';
  # now put everything in local srcrep
  my $meta = '';
  for my $entry (@{$dir->{'entry'} || []}) {
    $meta .= "$entry->{'md5'}  $entry->{'name'}\n";
    next if -e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}";
    mkdir_p("$srcrep/:upload");
    my $param = {
      'uri' => "$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/$entry->{'name'}",
      'filename' => "$srcrep/:upload/$$",
      'withmd5' => 1,
      'receiver' => \&BSHTTP::file_receiver,
    };
    my $res = BSRPC::rpc($param, undef, "rev=$rev->{'srcmd5'}");
    die("file download failed\n") unless $res && $res->{'md5'} eq $entry->{'md5'};
    mkdir_p("$srcrep/$packid");
    rename("$srcrep/:upload/$$", "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}") || die("rename $srcrep/:upload/$$ $srcrep/$packid/$entry->{'md5'}-$entry->{'name'}: $!\n");
  }
  #if ($dir->{'linkinfo'}) {
  #  $meta .= "$dir->{'linkinfo'}->{'srcmd5'}  /LINK\n";
  #  $meta .= "$dir->{'linkinfo'}->{'lsrcmd5'}  /LOCAL\n";
  #}
  if ($dir->{'linkinfo'}) {
    $dir->{'srcmd5'} = $rev->{'srcmd5'} = Digest::MD5::md5_hex($meta);
    $rev->{'rev'} = $rev->{'srcmd5'} unless $dir->{'rev'};
  } else {
    die("srcmd5 mismatch\n") if $dir->{'srcmd5'} ne Digest::MD5::md5_hex($meta);
  }
  if (! -e "$srcrep/$packid/$dir->{'srcmd5'}-MD5SUMS") {
    mkdir_p("$srcrep/:upload");
    mkdir_p("$srcrep/$packid");
    writestr("$srcrep/:upload/$$", "$srcrep/$packid/$dir->{'srcmd5'}-MD5SUMS", $meta);
  }
  return $rev;
}

sub expandsearchpath {
  my ($projid, $repoid) = @_;
  my %done;
  my @ret;
  my @path = {project => $projid, repository => $repoid};
  while (@path) {
    my $t = shift @path;
    my $prp = "$t->{'project'}/$t->{'repository'}";
    push @ret, $prp unless $done{$prp};
    $done{$prp} = 1;
    if (!@path) {
      last if $done{"/$prp"};
      my ($pid, $tid) = ($t->{'project'}, $t->{'repository'});
      my $proj = readproj($pid, 1);
      if (!$proj) { 
        $proj = remoteprojid($pid);
        $proj = fetchremoteproj($proj, $pid);
        die("project '$pid' does not exist\n") unless $proj;
        my @repo = grep {$_->{'name'} eq $tid} @{$proj->{'repository'} || []};
        if (@repo && $repo[0]->{'path'}) {
          for my $pathel (@{$repo[0]->{'path'}}) {
            # map projects to remote
            $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});
          }
        }
      }
      $done{"/$prp"} = 1;       # mark expanded
      my @repo = grep {$_->{'name'} eq $tid} @{$proj->{'repository'} || []};
      push @path, @{$repo[0]->{'path'}} if @repo && $repo[0]->{'path'};
    }
  }
  return @ret;
}

sub getconfig {
  my ($cgi, $projid, $repoid) = @_;
  my @path = expandsearchpath($projid, $repoid);
  my $config = '';
  my $macros = "%vendor openSUSE Build Service\n";
  my $lastr = '';
  for my $prp (reverse @path) {
    my ($p, $r) = split('/', $prp, 2);
    my $c;
    if (-s "$projectsdir/$p.conf") {
      $c = readstr("$projectsdir/$p.conf");
    } elsif (!-e "$projectsdir/$p.xml") {
      my $proj = remoteprojid($p);
      $c = fetchremoteconfig($proj, $p);
    }
    next unless defined $c;
    $config .= "\n### from $p\n";
    $config .= "%define _repository $r\n";
    if ($c =~ /^(.*\n)?\s*macros:[^\n]*\n(.*)/si) {
      $c = defined($1) ? $1 : '';
      $macros .= "\n### from $p\n";
      $macros .= "%_repository $r\n";
      $macros .= $2;
      $lastr = $r;
    }
    $config .= $c;
  }
  if ($lastr ne $repoid) {
    $macros .= "\n### from $projid\n";
    $macros .= "%_repository $repoid\n";
  }
  $macros .= "\n%distribution $projid / $repoid\n";
  $config .= "\nMacros:\n$macros" if $macros ne '';
  return ($config, 'Content-Type: text/plain');
}

sub getprojectconfig {
  my ($cgi, $projid) = @_;
  my $proj = readproj($projid);
  my $config = readstr("$projectsdir/$projid.conf", 1);
  $config = '' unless defined $config;
  return ($config, 'Content-Type: text/plain');
}

sub putprojectconfig {
  my ($cgi, $projid) = @_;
  my $proj = readproj($projid);
  mkdir_p("$srcrep/:upload");
  my $uploaded = BSServer::read_file("$srcrep/:upload/$$");
  die("upload failed\n") unless $uploaded;
  if (-s "$srcrep/:upload/$$") {
    rename("$srcrep/:upload/$$", "$projectsdir/$projid.conf") || die("rename $srcrep/:upload/$$ $projectsdir/$projid.conf: $!\n");
  } else {
    unlink("$projectsdir/$projid.conf") || die("unlink $projectsdir/$projid.conf: $!\n");
  }
  notify_repservers('project', $projid);
  BSHermes::notify("SRCSRV_UPDATE_PROJECT_CONFIG", { "project" => $projid });

  return $BSStdServer::return_ok;
}

##########################################################################

sub getsources {
  my ($cgi, $projid, $packid, $srcmd5) = @_;
  my $files = lsrep($projid, $packid, $srcmd5);
  delete $files->{'/LINK'};
  delete $files->{'/LOCAL'};
  my @send = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} keys %$files;
  BSServer::reply_cpio(\@send);
  return undef;
}

sub getfilelist {
  my ($cgi, $projid, $packid) = @_;

  my $view = $cgi->{'view'};
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("nothing known\n") unless $rev;
  my $ret = {};
  my $li = {};
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  if ($files->{'_link'}) {
    my %lrev = %$rev;
    $lrev{'name'} = $packid;
    my $lfiles = handlelinks($projid, \%lrev, $files, $rev);
    delete $lrev{'rev'};
    if ($cgi->{'expand'}) {
      die("$lfiles\n") if !ref $lfiles;
      $files = $lfiles;
      %$rev = %lrev;
    } else {
      delete $lrev{'srcmd5'} if !ref($lfiles) && ! -e "$srcrep/$packid/$lrev{'srcmd5'}-_linkerror";
      $ret->{'xsrcmd5'} = $lrev{'srcmd5'} if $lrev{'srcmd5'};
      $ret->{'error'} = $lfiles unless ref $lfiles;
      $li->{'xsrcmd5'} = $lrev{'srcmd5'} if $lrev{'srcmd5'};
      $li->{'error'} = $lfiles unless ref $lfiles;
    }
  }

  if ($cgi->{'extension'}) {
    for (keys %$files) {
      delete $files->{$_} unless /\.\Q$cgi->{'extension'}\E$/;
    }
  }

  if ($view && $view eq 'cpio') {
    delete $files->{'/LINK'};
    delete $files->{'/LOCAL'};
    my @files = map {{'name' => $_, 'filename' => "$srcrep/$packid/$files->{$_}-$_"}} sort keys %$files;
    BSServer::reply_cpio(\@files);
    return undef;
  }

  $ret->{'name'} = $packid;
  $ret->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';
  $ret->{'rev'} = $rev->{'rev'} if exists $rev->{'rev'};
  $ret->{'vrev'} = $rev->{'vrev'} if exists $rev->{'vrev'};
  my $limd5;
  my $lfiles = $files;
  if ($files->{'/LINK'}) {
    $limd5 = $files->{'/LINK'};
    $ret->{'lsrcmd5'} = $files->{'/LOCAL'};
    $li->{'lsrcmd5'} = $files->{'/LOCAL'};
    $lfiles = lsrep($projid, $packid, $files->{'/LOCAL'});
    die("bad source link\n") unless $lfiles->{'_link'};
  }
  if ($lfiles->{'_link'}) {
    my $l = readxml("$srcrep/$packid/$lfiles->{'_link'}-_link", $BSXML::link, 1);
    die("bad source link\n") if $limd5 && !$l;
    if ($l) {
      $l->{'project'} = $projid unless exists $l->{'project'};
      $l->{'package'} = $packid unless exists $l->{'package'};
      $ret->{'tproject'} = $l->{'project'};
      $ret->{'tpackage'} = $l->{'package'};
      $ret->{'trev'} = $l->{'rev'} if $l->{'rev'};
      $ret->{'tsrcmd5'} = $limd5 if $limd5;
      $li->{'project'} = $l->{'project'};
      $li->{'package'} = $l->{'package'};
      $li->{'rev'} = $l->{'rev'} if $l->{'rev'};
      $li->{'srcmd5'} = $limd5 if $limd5;
    }
  }
  delete $files->{'/LINK'};
  delete $files->{'/LOCAL'};

  my @res;
  for my $filename (sort keys %$files) {
    my @s = stat("$srcrep/$packid/$files->{$filename}-$filename");
    if (@s) {
      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'size' => $s[7], 'mtime' => $s[9]};
    } else {
      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'error' => "$!"};
    }
  }
  $ret->{'linkinfo'} = $li if %$li;
  $ret->{'entry'} = \@res;
  return ($ret, $BSXML::dir);
}

sub getfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("$filename: no such project/package\n") unless $rev;
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  die("$filename: no such file\n") unless $files->{$filename};
  my @s = stat("$srcrep/$packid/$files->{$filename}-$filename");
  die("$srcrep/$packid/$files->{$filename}-$filename: $!\n") unless @s;
  BSServer::reply_file("$srcrep/$packid/$files->{$filename}-$filename", "Content-Length: $s[7]");
  return undef;
}

sub putfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("unknown project/package\n") unless $rev;
  mkdir_p("$srcrep/:upload");
  my $uploaded = BSServer::read_file("$srcrep/:upload/$$", 'withmd5' => 1);
  die("upload failed\n") unless $uploaded;
  my $srname = "$uploaded->{'md5'}-$filename";
  if (! -e "$srcrep/$packid/$srname") {
    mkdir_p "$srcrep/$packid";
    rename("$srcrep/:upload/$$", "$srcrep/$packid/$srname") || die("rename $srcrep/:upload/$$ $srcrep/$packid/$srname: $!\n");
  } else {
    #already there, all the upload work was unneeded...
    unlink("$srcrep/:upload/$$");
  }
  # create new meta file
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  $files->{$filename} = $uploaded->{'md5'};
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  my $user = defined($cgi->{'user'}) ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  $rev = addrev($projid, $packid, $files, $user, $comment, $cgi->{'rev'});
  return ($rev, $BSXML::revision);
}

sub sourcediff {
  my ($cgi, $projid, $packid) = @_;

  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;

  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("unknown project/package\n") unless $rev;
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  my $orev = $cgi->{'orev'};
  if ($projid eq $oprojid && $packid eq $opackid && !defined($cgi->{'orev'}) && $rev->{'rev'}) {
    $orev = $rev->{'rev'} - 1;
  }
  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest');
  die("unknown other project/package\n") unless $orev;
  my $ofiles = lsrep($oprojid, $opackid, $orev->{'srcmd5'});
  if ($cgi->{'expand'} || ($files->{'_link'} && !$ofiles->{'_link'}) || ($ofiles->{'_link'} && !$files->{'_link'})) {
    # expand links
    if ($files->{'_link'}) {
      my %lrev = %$rev;
      $lrev{'name'} = $packid;
      $files = handlelinks($projid, \%lrev, $files, $rev);
      die("bad link: $files\n") unless ref $files;
      delete $files->{'/LINK'};
      delete $files->{'/LOCAL'};
    }
    if ($ofiles->{'_link'}) {
      my %olrev = %$orev;
      $olrev{'name'} = $opackid;
      $ofiles = handlelinks($oprojid, \%olrev, $ofiles, $orev);
      die("bad link: $ofiles\n") unless ref $ofiles;
      delete $ofiles->{'/LINK'};
      delete $ofiles->{'/LOCAL'};
    }
  }
  my $tmpdir = "$srcrep/:upload/srcdiff$$";
  my $d = BSSrcdiff::srcdiff("$srcrep/$opackid", $ofiles, "$srcrep/$packid", $files, 200, 16000, $tmpdir);
  return ($d, 'Content-Type: text/plain');
}

sub isascii {
  my ($file) = @_;
  local *F;
  open(F, '<', $file) || die("$file: $!\n");
  my $buf = '';
  sysread(F, $buf, 4096);
  close F;
  return 1 unless $buf =~ /[\000-\010\016-\037]/s;
  return 0;
}

sub rundiff {
  my ($file1, $file2, $label, $outfile) = @_;
  my $pid;
  if (!($pid = xfork())) {
    if (!open(STDOUT, '>>', $outfile)) {
      print STDERR "$outfile: $!\n";
      exit(2);
    }
    exec('diff', '-up', '--label', "$label.orig", '--label', $label, $file1, $file2);
    exit(2);
  }
  waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
  my $status = $?;
  return 1 if $status == 0 || $status == 0x100;
  return undef;
}

sub putinsrcrep {
  my ($projid, $packid, $tmpfile, $filename) = @_;

  open(F, '<', $tmpfile) || die("$tmpfile: $!\n");
  my $ctx = Digest::MD5->new;
  $ctx->addfile(*F);
  close F;
  my $md5 = $ctx->hexdigest();
  if (! -e "$srcrep/$packid/$md5-$filename") {
    rename($tmpfile, "$srcrep/$packid/$md5-$filename") || die("rename $tmpfile $srcrep/$packid/$md5-$filename: $!\n");
  }
  unlink($tmpfile);
  return $md5;
}

sub findprojectpatchname {
  my ($files) = @_;

  my $i = "";
  while ($files->{"project$i.diff"}) {
    $i = '0' unless $i;
    $i++;
  }
  return "project$i.diff";
}

#
# we are going to commit files to projid/packid, all data is already present
# in the src repository.
# if it was a link before, try to keep this link
#
sub keeplink {
  my ($projid, $packid, $files) = @_;

  return $files if !defined($files) || !%$files;
  return $files if $files->{'_link'};
  my $orev = getrev($projid, $packid, 'latest');
  my $ofilesl = lsrep($projid, $packid, $orev->{'srcmd5'});
  return $files unless $ofilesl && $ofilesl->{'_link'};
  my $l = readxml("$srcrep/$packid/$ofilesl->{'_link'}-_link", $BSXML::link);
# my $changedlink = 0;
# if ($l->{'patches'}) {
#   for (reverse @{$l->{'patches'}->{''} || []}) {
#     my $type = (keys %$_)[0];
#     if ($type eq 'apply') {
#	$_ = undef;
#	$changedlink = 1;
#	next;
#      }
#      last;
#    }
#    $l->{'patches'}->{''} = grep {defined($_)} @{$l->{'patches'}->{''}};
#  }

  # expand old link
  my %olrev = %$orev;
  $olrev{'name'} = $packid;
  my $ofiles = handlelinks($projid, \%olrev, $ofilesl, $orev);
  die("bad link: $ofiles\n") unless ref $ofiles;
  my $lsrcmd5 = $ofiles->{'/LINK'};
  delete $ofiles->{'/LINK'};
  delete $ofiles->{'/LOCAL'};

  # now create diff between $ofiles and $files
  my $nfiles = { %$ofilesl };
  unlink("$srcrep/:upload/$$");
  my @dfiles;
  for my $file (sort keys %{{%$files, %$ofiles}}) {
    if ($ofiles->{$file}) {
      if (!$files->{$file}) {
	push @dfiles, $file;
	delete $nfiles->{$file};
	next;
      }
      if ($ofiles->{$file} eq $files->{$file}) {
	next;
      }
      if (!isascii("$srcrep/$packid/$files->{$file}-$file") || !isascii("$srcrep/$packid/$ofiles->{$file}-$file")) {
	$nfiles->{$file} = $files->{$file};
	next;
      }
    } else {
      if (!isascii("$srcrep/$packid/$files->{$file}-$file")) {
	$nfiles->{$file} = $files->{$file};
	next;
      }
    }
    # both are ascii, create diff
    mkdir_p("$srcrep/:upload");
    if (!rundiff($ofiles->{$file} ? "$srcrep/$packid/$ofiles->{$file}-$file" : '/dev/null', "$srcrep/$packid/$files->{$file}-$file", $file, "$srcrep/:upload/$$")) {
      $nfiles->{$file} = $files->{$file};
    }
  }
  my $lchanged;
  for (@dfiles) {
    push @{$l->{'patches'}->{''}}, {'delete' => {'name' => $_}};
    $lchanged = 1;
  }
  if (-s "$srcrep/:upload/$$") {
    my $ppatch = findprojectpatchname($nfiles);
    $nfiles->{$ppatch} = putinsrcrep($projid, $packid, "$srcrep/:upload/$$", $ppatch);
    push @{$l->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};
    $lchanged = 1;
  } else {
    unlink("$srcrep/:upload/$$");
  }
  if ($lchanged) {
    writexml("$srcrep/:upload/$$", undef, $l, $BSXML::link);
    $nfiles->{'_link'} = putinsrcrep($projid, $packid, "$srcrep/:upload/$$", '_link')
  }
  return $nfiles;
}

# integrate link from opackid to packid into packid
sub integratelink {
  my ($files, $projid, $packid, $ofiles, $oprojid, $opackid, $l) = @_;

  my $nl = readxml("$srcrep/$packid/$files->{'_link'}-_link", $BSXML::link);

  # FIXME: remove hunks from patches that deal with replaced/deleted files
  my $lchanged;
  my %dontcopy;
  $dontcopy{'_link'} = 1;
  if ($nl->{'patches'}) {
    for (@{$nl->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if ($type eq 'add' || $type eq 'apply') {
	$dontcopy{$_->{$type}->{'name'}} = 1;
      }
    }
  }
  if ($l->{'patches'}) {
    for (@{$l->{'patches'}->{''} || []}) {
      my $type = (keys %$_)[0];
      if ($type eq 'delete' && $files->{$_->{'delete'}->{'name'}}) {
	delete $files->{$_->{'delete'}->{'name'}};
      } else {
	$lchanged = 1;
	$nl->{'patches'} ||= {};
	if ($type eq 'apply') {
	  my $oppatch = $_->{'apply'}->{'name'};
	  if ($files->{$oppatch}) {
	    $dontcopy{$oppatch} = 1;
	    # argh, patch file already exists, rename...
	    my $ppatch = findprojectpatchname($files);
	    unlink("$srcrep/:upload/$$");
	    link("$srcrep/$opackid/$ofiles->{$oppatch}-$oppatch", "$srcrep/:upload/$$") || die("link $srcrep/$opackid/$ofiles->{$oppatch}-$oppatch $srcrep/:upload/$$: $!\n");
            $files->{$ppatch} = putinsrcrep($projid, $packid, "$srcrep/:upload/$$", $ppatch);
	    push @{$nl->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};
	    next;
	  }
	}
	if ($type eq 'add') {
	  my $oppatch = $_->{'add'}->{'name'};
	  die("cannot apply patch $oppatch twice\n") if $dontcopy{$oppatch};
	}
        push @{$nl->{'patches'}->{''}}, $_;
      }
    }
  }
  if ($lchanged) {
    writexml("$srcrep/:upload/$$", undef, $nl, $BSXML::link);
    $files->{'_link'} = putinsrcrep($projid, $packid, "$srcrep/:upload/$$", '_link')
  }
  for (sort keys %$ofiles) {
    next if $dontcopy{$_};
    $files->{$_} = $ofiles->{$_};
  }
  return $files;
}

sub sourcecommit {
  my ($cgi, $projid, $packid) = @_;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("unknown project/package\n") unless $rev;
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  my $user = defined($cgi->{'user'}) ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  $rev = addrev($projid, $packid, $files, $user, $comment);
  return ($rev, $BSXML::revision);
}

sub sourcecommitfilelist {
  my ($cgi, $projid, $packid) = @_;
  my $user = defined($cgi->{'user'}) ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  mkdir_p("$srcrep/:upload");
  my $uploaded = BSServer::read_file("$srcrep/:upload/$$");
  die("upload failed\n") unless $uploaded;
  my $fl = readxml("$srcrep/:upload/$$", $BSXML::dir);
  unlink("$srcrep/:upload/$$");
  # make sure we know every file
  my @missing;
  my $files = {};
  for my $entry (@{$fl->{'entry'} || []}) {
    BSVerify::verify_filename($entry->{'name'});
    BSVerify::verify_md5($entry->{'md5'});
    if (! -e "$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}") {
      push @missing, $entry;
    } else {
      die("duplicate file: $entry->{'name'}\n") if exists $files->{$entry->{'name'}};
      $files->{$entry->{'name'}} = $entry->{'md5'};
    }
  }
  if (@missing) {
    my $res = {'name' => $packid, 'error' => 'missing', 'entry' => \@missing};
    return ($res, $BSXML::dir);
  }
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  if (-e "$projectsdir/$projid.pkg/$packid.upload-MD5SUMS") {
    # autocommit old update revision so that it doesn't get lost
    my $uploadfiles = lsrep($projid, $packid, 'upload');
    addrev($projid, $packid, $uploadfiles, $user, 'autocommit');
  }
  my $rev = addrev($projid, $packid, $files, $user, $comment);
  $cgi->{'rev'} = $rev->{'rev'};
  return getfilelist($cgi, $projid, $packid);
}

sub sourcecopy {
  my ($cgi, $projid, $packid) = @_;
  die("illegal rev parameter\n") if $cgi->{'rev'} && $cgi->{'rev'} ne 'upload';
  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;
  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;
  my $orev = $cgi->{'orev'};
  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest');
  my $files = lsrep($oprojid, $opackid, $orev->{'srcmd5'});
  die("need a revision to copy\n") if !$cgi->{'rev'} && $oprojid eq $projid && $opackid eq $packid && !($files->{'_link'} && $cgi->{'expand'});

  my $autosimplifylink;

  if ($files->{'_link'}) {
    # fix me: do this in a more generic way
    my $l = readxml("$srcrep/$opackid/$files->{'_link'}-_link", $BSXML::link, 1);
    if ($l) {
      my $lprojid = $oprojid;
      my $lpackid = $opackid;
      my $lrev = $l->{'rev'};
      $lprojid = $l->{'project'} if exists $l->{'project'};
      $lpackid = $l->{'package'} if exists $l->{'package'};
      if ($lprojid eq $projid && $lpackid eq $packid) {
        # copy destination is target of link
	# we're integrating this link
        $lrev = getrev($lprojid, $lpackid, $lrev);
	my $lfiles = lsrep($lprojid, $lpackid, $lrev->{'srcmd5'});
	if ($lfiles->{'_link'} && !$cgi->{'expand'}) {
	  $files = integratelink($lfiles, $lprojid, $lpackid, $files, $oprojid, $opackid, $l);
	} else {
	  # auto expand
	  $cgi->{'expand'} = 1;
	}
	$autosimplifylink = $l;
      }
    }
  }

  if ($files->{'_link'} && $cgi->{'expand'}) {
    my %olrev = %$orev;
    $olrev{'name'} = $opackid;
    $files = handlelinks($oprojid, \%olrev, $files, $orev);
    die("bad link: $files\n") unless ref $files;
    delete $files->{'/LINK'};
    delete $files->{'/LOCAL'};
  }
  if ($opackid ne $packid) {
    # link sources over
    mkdir_p("$srcrep/$packid");
    for my $file (sort keys %$files) {
      if (! -e "$srcrep/$packid/$files->{$file}-$file") {
        link("$srcrep/$opackid/$files->{$file}-$file", "$srcrep/$packid/$files->{$file}-$file");
	die("link error $srcrep/$opackid/$files->{$file}-$file\n") unless -e "$srcrep/$packid/$files->{$file}-$file";
      }
    }
  }
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  my $user = defined($cgi->{'user'}) ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  my $rev = addrev($projid, $packid, $files, $user, $comment, $cgi->{'rev'});

  if ($autosimplifylink && !$autosimplifylink->{'rev'}) {
    eval {
      my $latestorev = getrev($oprojid, $opackid);
      if ($latestorev->{'srcmd5'} eq $orev->{'srcmd5'}) {
        # simplify link
        my $nl = {};
        $nl->{'project'} = $autosimplifylink->{'project'} if $autosimplifylink->{'project'};
        $nl->{'package'} = $autosimplifylink->{'package'} if $autosimplifylink->{'package'};
        $nl->{'cicount'} = $autosimplifylink->{'cicount'} if $autosimplifylink->{'cicount'};
        writexml("$srcrep/:upload/$$", undef, $nl, $BSXML::link);
        my $ofiles = {};
        $ofiles->{'_link'} = putinsrcrep($oprojid, $opackid, "$srcrep/:upload/$$", '_link');
        addrev($oprojid, $opackid, $ofiles, 'buildservice-autocommit', "auto commit by copy to link target\n");
      }
    };
    warn($@) if $@;
  }

  return ($rev, $BSXML::revision);
}

sub sourcecmd {
  my ($cgi, $projid, $packid) = @_;
  return sourcediff($cgi, $projid, $packid) if $cgi->{'cmd'} eq 'diff';
  return sourcecommit($cgi, $projid, $packid) if $cgi->{'cmd'} eq 'commit';
  return sourcecommitfilelist($cgi, $projid, $packid) if $cgi->{'cmd'} eq 'commitfilelist';
  return sourcecopy($cgi, $projid, $packid) if $cgi->{'cmd'} eq 'copy';
  die("unknown command \"$cgi->{'cmd'}\"\n");
}

sub delfile {
  my ($cgi, $projid, $packid, $filename) = @_;
  die("no filename\n") unless defined($filename) && $filename ne '';
  die("bad filename\n") if $filename =~ /\// || $filename =~ /^\./;
  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');
  die("unknown project/package\n") unless $rev;
  my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
  die("file '$filename' does not exist\n") unless $files->{$filename};
  delete $files->{$filename};
  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};
  my $user = defined($cgi->{'user'}) ? $cgi->{'user'} : 'unknown';
  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';
  $rev = addrev($projid, $packid, $files, $user, $comment, $cgi->{'rev'});
  return ($rev, $BSXML::revision);
}

sub getrepositorylist {
  my ($cgi, $projid) = @_;
  my $proj = readproj($projid);
  my @res = map {{'name' => $_->{'name'}}} @{$proj->{'repository'} || []};
  return ({'entry' => \@res}, $BSXML::dir);
}

sub getrepository {
  my ($cgi, $projid, $repoid) = @_;
  my $proj = readproj($projid);
  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];
  die("$repoid: no such repository\n") unless $repo;
  return ($repo, $BSXML::repo);
}

sub getarchlist {
  my ($cgi, $projid, $repoid) = @_;
  my $proj = readproj($projid);
  my @repo = grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []};
  die("$repoid: no such repository\n") unless @repo;
  my @res = map {{'name' => $_}} @{$repo[0]->{'arch'} || []};
  return ({'entry' => \@res}, $BSXML::dir);
}

sub getresult {
  my ($cgi, $projid) = @_;

  if ($cgi->{'oldstate'} && !$BSStdServer::isajax) {
    my @args = "oldstate=$cgi->{'oldstate'}";
    push @args, map {"view=$_"} @{$cgi->{'view'} || []};
    push @args, map {"repository=$_"} @{$cgi->{'repository'} || []};
    push @args, map {"arch=$_"} @{$cgi->{'arch'} || []};
    push @args, map {"package=$_"} @{$cgi->{'package'} || []};
    push @args, map {"code=$_"} @{$cgi->{'code'} || []};
    BSHandoff::handoff($ajaxsocket, "/build/$projid/_result", undef, @args);
    exit(0);
  }

  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};
  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};
  my %view = map {$_ => 1} @{$cgi->{'view'} || ['status']};
  my %code = map {$_ => 1} @{$cgi->{'code'} || []};

  my $proj = readproj($projid);
  if ($cgi->{'repository'}) {
    my %knownrepoids = map {$_->{'name'} => 1} @{$proj->{'repository'} || []};
    for (@{$cgi->{'repository'}}) {
      die("unknown repository '$_'\n") if !$knownrepoids{$_};
    }
  }
  if ($cgi->{'package'}) {
    my %knownpackids = map {$_ => 1} findpackages($projid);
    for (@{$cgi->{'package'}}) {
      die("unknown package '$_'\n") if !$knownpackids{$_};
    }
  }
  my @prpas;
  for my $repo (@{$proj->{'repository'} || []}) {
    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};
    my @archs = @{$repo->{'arch'} || []};
    @archs = grep {$archfilter{$_}} @archs if %archfilter;
    push @prpas, map {"$projid/$repo->{'name'}/$_"} @archs;
  }

  BSWatcher::addfilewatcher("$projectsdir/$projid.xml") if $BSStdServer::isajax;

  if (!@prpas) {
    my $state = "00000000000000000000000000000000";
    return undef if $BSStdServer::isajax && $cgi->{'oldstate'} && $state eq $cgi->{'oldstate'};
    return ({'state' => $state}, $BSXML::resultlist);
  }

  my $ps = {};
  # XXX FIXME multiple repo handling
  for my $rrserver ($BSConfig::reposerver) {
    my @args;
    push @args, "oldstate=$cgi->{'oldstate'}" if $cgi->{'oldstate'};
    push @args, map {"prpa=$_"} @prpas;
    push @args, map {"package=$_"} @{$cgi->{'package'} || []};
    push @args, map {"code=$_"} @{$cgi->{'code'} || []};
    push @args, "withbinarylist" if $view{'binarylist'};
    eval {
      $ps = BSWatcher::rpc("$rrserver/_result", $BSXML::resultlist, @args);
    };
    if ($@) {
      print "warning: $rrserver: $@";
      $ps = {};
    }
  }
  return if $BSStdServer::isajax && !defined($ps);
  if ($view{'summary'}) {
    my @order = ('succeeded', 'failed', 'expansion error', 'broken', 'scheduled');
    my %order = map {$_ => 1} @order;
    for my $p (@{$ps->{'result'} || []}) {
      my %sum;
      for my $pp (@{$p->{'status'} || []}) {
        $sum{$pp->{'code'}}++ if $pp->{'code'};
      }
      my @sum = grep {exists $sum{$_}} @order;
      push @sum, grep {!$order{$_}} sort keys %sum;
      $p->{'summary'} = {'statuscount' => [ map {{'code' => $_, 'count' => $sum{$_}}} @sum ] };
    }
  }
  if (!$view{'status'}) {
    for my $p (@{$ps->{'result'} || []}) {
      delete $p->{'status'};
    }
  }
  return ($ps, $BSXML::resultlist);
}

sub docommand {
  my ($cgi, $projid) = @_;

  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};
  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};

  my $proj = readproj($projid);
  my @prpas;
  for my $repo (@{$proj->{'repository'} || []}) {
    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};
    my @archs = @{$repo->{'arch'} || []};
    @archs = grep {$archfilter{$_}} @archs if %archfilter;
    push @prpas, map {"$projid/$repo->{'name'}/$_"} @archs;
  }
  die("no repository defined\n") unless @prpas;
  my @packids = @{$cgi->{'package'} || []};
  if (@packids) {
    my %packids = map {$_ => 1} findpackages($projid);
    my @badpacks = grep {!$packids{$_}} @packids;
    die("unknown package: @badpacks\n") if @badpacks;
  } else {
    @packids = findpackages($projid);
  }
  die("no packages defined\n") unless @packids;
  
  # XXX FIXME multiple repo handling
  my $res;
  for my $rrserver ($BSConfig::reposerver) {
    my @args;
    push @args, map {"prpa=$_"} @prpas;
    push @args, map {"package=$_"} @packids;
    push @args, map {"code=$_"} @{$cgi->{'code'} || []};
    push @args, "cmd=$cgi->{'cmd'}";
    $res = BSWatcher::rpc("$rrserver/_command", undef, @args);
  }
  return $res;
}

sub checkprojrepoarch {
  my ($projid, $repoid, $arch, $remoteok) = @_;
  my $proj = readproj($projid, 1);
  $proj = remoteprojid($projid) if $remoteok && (!$proj || $proj->{'remoteurl'});
  die("project '$projid' does not exist\n") if !$proj;
  die("project '$projid' is remote\n") if $proj->{'remoteurl'} && !$remoteok;
  return $proj if $proj->{'remoteurl'};
  return $proj unless defined $repoid;
  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];
  die("project has no repository '$repoid'\n") unless $repo;
  return $proj unless defined $arch;
  die("project has no architecture '$arch'\n") unless grep {$_ eq $arch} @{$repo->{'arch'} || []};
  return $proj;
}

sub getbinarylist {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;

  checkprojrepoarch($projid, $repoid, $arch);
  my $view = $cgi->{'view'};
  my @args;
  push @args, "view=$view" if $view;
  push @args, map {"binary=$_"} @{$cgi->{'binary'} || []};
  if ($view && ($view eq 'cache' || $view eq 'cpio')) {
    if (!$BSStdServer::isajax) {
      BSHandoff::handoff($ajaxsocket, "/build/$projid/$repoid/$arch/$packid", undef, @args);
      exit(0);
    }
    my $param = {
      'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid",
      'ignorestatus' => 1,
      'receiver' => \&BSServer::reply_receiver,
    };
    BSWatcher::rpc($param, undef, @args);
    return undef;
  }
  my $bl = BSWatcher::rpc("$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid", $BSXML::binarylist, @args);
  return ($bl, $BSXML::binarylist);
}

sub getbinary {
  my ($cgi, $projid, $repoid, $arch, $packid, $filename) = @_;
  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);
  if ($proj->{'remoteurl'}) {
    # hack: reroute to /getbinaries so that our local cache is used
    die("can only access remote _repository files\n") unless $packid eq '_repository';
    die("need the raw package name as filename for remote repository access\n") if $filename =~ /\.(?:rpm|deb)$/;
    my @args;
    push @args, "project=$projid";
    push @args, "repository=$repoid";
    push @args, "arch=$arch";
    push @args, "binaries=$filename";
    push @args, "raw=1";
    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);
    exit(0);
  }
  my $param = {
    'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/$filename",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
  };
  BSWatcher::rpc($param);
  return undef;
}

sub putbinary {
  my ($cgi, $projid, $repoid, $arch, $filename) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my @args;
  push @args, 'ignoreolder=1' if $cgi->{'ignoreolder'};
  push @args, 'wipe=1' if $cgi->{'wipe'};
  my $param = {
    'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/_repository/$filename",
    'request' => 'PUT',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  # XXX add return type checking
  return BSWatcher::rpc($param, undef, @args);
}

sub getlogfile {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);

  if (!$cgi->{'start'}) {
    # check if the package is broken
    my $rev = getrev($projid, $packid, 'build');
    if ($rev) {
      my $files = lsrep($projid, $packid, $rev->{'srcmd5'});
      if (ref($files) && $files->{'_link'}) {
	my %lrev = %$rev;
        $lrev{'name'} = $packid;
        $files = handlelinks($projid, \%lrev, $files, $rev);
	if (!ref $files) {
	  my $error = "$files\n";
	  if ($lrev{'srcmd5'}) {
	    $files = lsrep($projid, $packid, $lrev{'srcmd5'});
	    if ($files->{'_linkerror'}) {
	      $error = readstr("$srcrep/$packid/$files->{'_linkerror'}-_linkerror", 1);
	    }
	  }
	  return $error;
	}
      }
    }
  }

  my @args = ();
  push @args, 'nostream' if $cgi->{'nostream'};
  push @args, "start=$cgi->{'start'}" if defined $cgi->{'start'};
  push @args, "end=$cgi->{'end'}" if defined $cgi->{'end'};
  if (!$BSStdServer::isajax) {
    my $url = "/build/$projid/$repoid/$arch/$packid/_log";
    BSHandoff::handoff($ajaxsocket, $url, undef, @args);
    exit(0);
  }
  my $param = {
    'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/_log",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
    'joinable' => 1,
  };
  BSWatcher::rpc($param, undef, @args);
  return undef; # always streams result
}

sub getbuildhistory {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $buildhist = BSWatcher::rpc("$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/_history", $BSXML::buildhist);
  return ($buildhist, $BSXML::buildhist);
}

sub getbuildinfo {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my @args;
  push @args, 'internal=1' if $cgi->{'internal'};
  push @args, map {"add=$_"} @{$cgi->{'add'} || []};
  my $buildinfo = BSWatcher::rpc("$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo", $BSXML::buildinfo, @args);
  return ($buildinfo, $BSXML::buildinfo);
}

sub getbuildinfo_post {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my @args;
  push @args, map {"add=$_"} @{$cgi->{'add'} || []};
  my $param = {
    'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo",
    'request' => 'POST',
    'data' => \&BSServer::forward_sender,
    'chunked' => 1,
  };
  my $buildinfo = BSWatcher::rpc($param, $BSXML::buildinfo, @args);
  return ($buildinfo, $BSXML::buildinfo);
}

sub getbuildstatus {
  my ($cgi, $projid, $repoid, $arch, $packid) = @_;
  checkprojrepoarch($projid, $repoid, $arch);
  my $status = BSWatcher::rpc("$BSConfig::reposerver/build/$projid/$repoid/$arch/$packid/_status", $BSXML::buildstatus);
  return ($status, $BSXML::buildstatus);
}

sub getworkerstatus {
  my ($cgi) = @_;
  my @args;
  push @args, 'scheduleronly' if $cgi->{'scheduleronly'};
  push @args, map {"arch=$_"} @{$cgi->{'arch'} || []};
  my $ws = BSWatcher::rpc("$BSConfig::reposerver/workerstatus", $BSXML::workerstatus, @args);
  delete $_->{'uri'} for @{$ws->{'idle'}};
  delete $_->{'uri'} for @{$ws->{'building'}};
  return ($ws, $BSXML::workerstatus);
}

sub getajaxstatus {
  my ($cgi) = @_;
  if (!$BSStdServer::isajax) {
    BSHandoff::handoff($ajaxsocket, '/ajaxstatus');
    exit(0);
  }
  my $r = BSWatcher::getstatus();
  return ($r, $BSXML::ajaxstatus);
}

sub search_proj {
  my ($cgi, $match, $id) = @_;
  $match =~ s/^\[(.*)\]$/$1/s;
  my $data = [];
  for my $projid (findprojects()) {
    my $proj = readproj($projid);
    push @$data, $proj;
  }
  $data = BSXPath::match($data, $match);
  if ($id) {
    for (@{$data || []}) {
      $_ = {'name' => $_->{'name'}};
    }
  }
  my $res = {'project' => $data};
  return ($res, $BSXML::collection);
}

sub search_pack {
  my ($cgi, $match, $id) = @_;
  $match =~ s/^\[(.*)\]$/$1/s;
  my $data = [];
  for my $projid (findprojects()) {
    my @packages = findpackages($projid);
    for my $packid (@packages) {
      my $pack = readpack($projid, $packid);
      $pack->{'project'} = $projid;
      push @$data, $pack;
    }
  }
  $data = BSXPath::match($data, $match);
  if ($id) {
    for (@{$data || []}) {
      $_ = {'name' => $_->{'name'}, 'project' => $_->{'project'}};
    }
  }
  my $res = {'package' => $data};
  return ($res, $BSXML::collection);
}

sub search_proj_id {
  return search_proj(@_, 1);
}

sub search_pack_id {
  return search_pack(@_, 1);
}

#############################################################################

sub search_published_updatedb {
  my ($cgi) = @_;
  die("unknown command '$cgi->{'cmd'}'\n") unless $cgi->{'cmd'} eq 'updatedb';
  my $data = BSServer::read_data();
  $data = Storable::thaw($data);
  die("no data\n") unless $data && @$data;
  my $patterndb;
  my $binarydb;
  my $repoinfodb;
  mkdir_p($extrepodb) unless -d $extrepodb;
  while (@$data) {
    my ($w, $k, $v) = splice(@$data, 0, 3);
    if ($w eq 'binary') {
      $binarydb = BSDB::opendb($extrepodb, 'binary') unless $binarydb;
      $binarydb->updateindex_rel($k || [], $v || []);
    } elsif ($w eq 'pattern') {
      $patterndb = BSDB::opendb($extrepodb, 'pattern') unless $patterndb;
      $patterndb->store($k, $v);
    } elsif ($w eq 'repoinfo') {
      if (!$repoinfodb) {
        $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');
        $repoinfodb->{'noindexatall'} = 1;
      };
      $repoinfodb->store($k, $v);
    } else {
      die("bad data type: '$w'\n");
    }
  }
  return $BSStdServer::return_ok;
}

#sub search_published_id {
#  my ($cgi, $what, $match) = @_;
#  my $res;
#  for my $rrserver ($BSConfig::reposerver) {
#    $res = BSRPC::rpc("$rrserver/search/published/$what/id", $BSXML::collection, "match=$match");
#    last if $res;
#  }
#  return ($res, $BSXML::collection);
#}
#
#sub search_published_binary_id {
#  return search_published_id($_[0], 'binary', $_[1]);
#}
#
#sub search_published_pattern_id {
#  return search_published_id($_[0], 'pattern', $_[1]);
#}

my %prp_to_repoinfo;

sub prp_to_repoinfo {
  my ($prp) = @_;

  my $repoinfo = $prp_to_repoinfo{$prp};
  if (!$repoinfo) {
    my $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');
    $repoinfo = $repoinfodb->fetch($prp);
    if ($repoinfo) {
      for (@{$repoinfo->{'prpsearchpath'} || []}) {
	next if ref($_);	# legacy
	my ($p, $r) = split('/', $_, 2);
	$_ = {'project' => $p, 'repository' => $r};
      }
    } else {
      $repoinfo = {'binaryorigins' => {}};
    }
    $prp_to_repoinfo{$prp} = $repoinfo;
  }
  return $repoinfo;
}

sub binary_key_to_data {
  my ($db, $key) = @_; 
  my @p = split('/', $key);
  my $binary = pop(@p);
  my $name = $binary;
  my $version = '';
  if ($name =~ s/-([^-]+-[^-]+)\.[^\.]+\.rpm$//) {
    $version = $1;
  } elsif ($name =~ s/_([^_]+)_[^_]+\.deb$//) {
    $version = $1;
  }
  my $arch = pop(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $project = shift(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $repository = shift(@p);
  my $prp = "$project/$repository";
  my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);
  my $type;
  $type = 'rpm' if $binary =~ /\.rpm$/;
  $type = 'deb' if $binary =~ /\.deb$/;
  my $res = {
    'name' => $name,
    'version' => $version,
    'arch' => $arch,
    'type' => $type,
    'project' => $project,
    'repository' => $repository,
    'filename' => $binary,
    'filepath' => $key,
  };
  $res->{'path'} = $repoinfo->{'prpsearchpath'} if $repoinfo->{'prpsearchpath'};
  $res->{'package'} = $repoinfo->{'binaryorigins'}->{"$arch/$binary"} if defined $repoinfo->{'binaryorigins'}->{"$arch/$binary"};
  $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'} if $res->{'path'};
  return $res;
}

sub pattern_key_to_data {
  my ($db, $key) = @_; 
  my @p = split('/', $key);
  my $filename = pop(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $project = shift(@p);
  while (@p > 1 && $p[0] =~ /:$/) {
    splice(@p, 0, 2, "$p[0]$p[1]");
  }
  my $repository = shift(@p);
  my @v = BSDBIndex::getvalues($db, $db->{'table'}, $key);
  return {} unless @v;
  my $res = $v[0];
  $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'} if $res->{'path'};
  $res->{'project'} = $project;
  $res->{'repository'} = $repository;
  $res->{'filename'} = $filename;
  $res->{'filepath'} = $key;
  return $res;
}

sub search_published_binary_id {
  my ($cgi, $match) = @_;
  my $binarydb = BSDB::opendb($extrepodb, 'binary');
  $binarydb->{'allkeyspath'} = 'name';
  $binarydb->{'noindex'} = {'arch' => 1, 'project' => 1, 'repository' => 1, 'package' => 1, 'type' => 1, 'path/project' => 1, 'path/repository' => 1};
  $binarydb->{'fetch'} = \&binary_key_to_data;
  $binarydb->{'cheapfetch'} = 1;
  my $rootnode = BSXPathKeys::node($binarydb, '');
  my $data = BSXPath::match($rootnode, $match) || [];
  # epoch?
  @$data = sort {Build::Rpm::verscmp($b->{'version'}, $a->{'version'}) || $a->{'name'} cmp $b->{'name'} || $a->{'arch'} cmp $b->{'arch'}} @$data;
  delete $_->{'path'} for @$data;
  my $res = {'binary' => $data};
  return ($res, $BSXML::collection);
}

sub search_published_pattern_id {
  my ($cgi, $match) = @_;
  my $patterndb = BSDB::opendb($extrepodb, 'pattern');
  $patterndb->{'noindex'} = {'project' => 1, 'repository' => 1};
  $patterndb->{'fetch'} = \&pattern_key_to_data;
  my $rootnode = BSXPathKeys::node($patterndb, '');
  my $data = BSXPath::match($rootnode, $match) || [];
  for (@$data) {
    delete $_->{'path'};
    delete $_->{'description'};
    delete $_->{'summary'};
  }
  my $res = {'pattern' => $data};
  return ($res, $BSXML::collection);
}

#############################################################################

sub search {
  my ($cgi, $in, $match) = @_;
  # gather all data
  my $data = [];
  if ($in eq 'projects') {
    for my $projid (findprojects()) {
      my $proj = readproj($projid);
      push @$data, $proj;
    }
  } elsif ($in eq 'packages') {
    for my $projid (findprojects()) {
      my @packages = findpackages($projid);
      for my $packid (@packages) {
        my $pack = readpack($projid, $packid);
	$pack->{'project'} = $projid;
        push @$data, $pack;
      }
    }
  } else {
    die("'in' parameter needs to be either 'projects' or 'packages'\n");
  }
  my $res;
  if ($cgi->{'values'}) {
    $data = BSXPath::valuematch($data, $match);
    $res = {'value' => $data};
  } else {
    $data = BSXPath::match($data, $match);
    if (exists $cgi->{'return'}) {
      $data = BSXPath::valuematch($data, $cgi->{'return'});
      $res = {'value' => $data};
    } elsif ($in eq 'projects') {
      $res = {'project' => $data};
    } else {
      $res = {'package' => $data};
    }
  }
  return ($res, $BSXML::collection);
}

sub postrepo {
  my ($cgi, $projid, $repoid, $arch) = @_;
  my $param = {
    'uri' => "$BSConfig::reposerver/build/$projid/$repoid/$arch/_repository",
    'request' => 'POST',
  };
  my $res = BSWatcher::rpc($param, $BSXML::collection, "match=$cgi->{'match'}");
  return ($res, $BSXML::collection);
}

sub published {
  my ($cgi, $projid, $repoid, $arch, $filename) = @_;
  my @args;
  die("unknown view '$cgi->{'view'}'\n") if $cgi->{'view'} && $cgi->{'view'} ne 'ymp' && $cgi->{'view'} ne 'fileinfo';
  push @args, "view=$cgi->{'view'}" if $cgi->{'view'};
  my $p = "/published";
  $p .= "/$projid" if defined $projid;
  $p .= "/$repoid" if defined $repoid;
  $p .= "/$arch" if defined $arch;
  $p .= "/$filename" if defined $filename;
  my $param = {
    'uri' => "$BSConfig::reposerver$p",
    'ignorestatus' => 1,
    'receiver' => \&BSServer::reply_receiver,
  };
  BSWatcher::rpc($param, undef, @args);
  return undef;
}

sub getsignkey {
  my ($cgi, $projid) = @_;

  while ($projid ne '') {
    my $sk = readstr("$projectsdir/$projid.pkg/_signkey", 1);
    if ($sk) {
      if ($cgi->{'withpubkey'}) {
        my $pk = readstr("$projectsdir/$projid.pkg/_pubkey", 1);
        $sk .= "\n" unless $sk =~ /\n$/s;
        $sk .= $pk;
      }
      return ($sk, 'Content-Type: text/plain') if $sk;
    }
    $projid =~ s/[^:]*$//;
    $projid =~ s/:$//;
  }
  return ('', 'Content-Type: text/plain');
}

####################################################################

sub getrequestlist {
  my ($cgi) = @_;

  my @requests = map {{'name' => $_}} sort(grep {!/^\./} ls($requestsdir));
  return ({'entry' => \@requests}, $BSXML::dir);
};

sub nextreqid {
  local *F;
  mkdir_p($requestsdir);
  BSUtil::lockopen(*F, '>>', "$requestsdir/.nextid");
  my $nextid = readstr("$requestsdir/.nextid", 1);
  $nextid ||= 1;
  writestr("$requestsdir/.nextid.new", "$requestsdir/.nextid", $nextid + 1);
  close F;
  return $nextid;
}

sub writereq {
  my ($oreq, $req) = @_;

  my $id;
  $id = $req->{'id'} if $req;
  $id = $oreq->{'id'} if $oreq && !defined($id);
  die unless defined $id;
  my $name = $id;
  if ($req) {
    writexml("$requestsdir/.$name", "$requestsdir/$name", $req, $BSXML::request);
  }
  mkdir_p($reqindexdb);
  my $db = BSDB::opendb($reqindexdb, '');
  $db->{'noindex'} = {'id' => 1};
  $db->updateindex($id, $oreq || {}, $req || {});
  if (!$req) {
    unlink("$requestsdir/$name");
  }
}

sub putrequest {
  my ($cgi, $id) = @_;
  my $reqxml = BSServer::read_data(1000000);
  my $req = XMLin($BSXML::request, $reqxml);
  BSVerify::verify_request($req);
  my $oreq = readxml("$requestsdir/$id", $BSXML::request, 1);
  die("no such request '$id'\n") unless $oreq;
  $req->{'id'} = $id;
  $req->{'history'} = [ @{$oreq->{'history'} || []} ];
  push @{$req->{'history'}}, $oreq->{'state'};
  $req->{'state'}->{'who'} = $cgi->{'user'} if defined $cgi->{'user'};
  my @lt = localtime(time());
  $req->{'state'}->{'when'} = sprintf("%04d-%02d-%02dT%02d:%02d:%02d", $lt[5] + 1900, $lt[4] + 1, @lt[3,2,1,0]);
  writereq($oreq, $req);
  BSHermes::notify("SRCSRV_REQUEST_CHANGE", BSHermes::requestParams($req, $cgi->{'user'}));
  return $BSStdServer::return_ok;
}

sub createrequest {
  my ($cgi) = @_;

  my $reqxml = BSServer::read_data(1000000);
  my $cmd = $cgi->{'cmd'};
  die("unknown command '$cmd'\n") unless $cmd eq 'create';
  my $req = XMLin($BSXML::request, $reqxml);
  if ($req->{'type'} eq 'submit' && $req->{'submit'} && $req->{'submit'}->{'source'} && !$req->{'submit'}->{'target'}) {
    # special hack: make source link target the submit request target
    my $projid = $req->{'submit'}->{'source'}->{'project'};
    my $packid = $req->{'submit'}->{'source'}->{'package'};
    my $rev = $req->{'submit'}->{'source'}->{'rev'};
    BSVerify::verify_projid($projid);
    BSVerify::verify_packid($packid);
    BSVerify::verify_rev($rev) if defined $rev;
    if (defined($projid) && defined($packid)) {
      my $files = lsrep($projid, $packid, $rev);
      if ($files->{'_link'}) {
	my $l = readxml("$srcrep/$packid/$files->{'_link'}-_link", $BSXML::link, 1);
        if ($l) {
	  $projid = $l->{'project'} if exists $l->{'project'};
	  $packid = $l->{'package'} if exists $l->{'package'};
	  $req->{'target'} = {'project' => $projid, 'package' => $packid};
	}
      }
    }
  }
  BSVerify::verify_request($req);
  die("request must not contain an id\n") if $req->{'id'};
  die("request must not contain a history\n") if $req->{'history'};
  $req->{'state'}->{'who'} = $cgi->{'user'} if defined $cgi->{'user'};
  my @lt = localtime(time());
  $req->{'state'}->{'when'} = sprintf("%04d-%02d-%02dT%02d:%02d:%02d", $lt[5] + 1900, $lt[4] + 1, @lt[3,2,1,0]);
  $req->{'id'} = nextreqid();
  writereq(undef, $req);
  BSHermes::notify("SRCSRV_REQUEST_CREATE", BSHermes::requestParams( $req, $cgi->{'user'}));
  return ($req, $BSXML::request);
}

sub getrequest {
  my ($cgi, $id) = @_;
  my $req = readxml("$requestsdir/$id", $BSXML::request, 1);
  die("no such request '$id'\n") unless $req;
  return ($req, $BSXML::request);
}

sub postrequest {
  my ($cgi, $id) = @_;

  my $cmd = $cgi->{'cmd'};
  die("unknown command '$cmd'\n") unless $cmd eq 'changestate';
  die("no new state\n") unless $cgi->{'newstate'};
  my $oreq = readxml("$requestsdir/$id", $BSXML::request, 1);
  die("no such request '$id'\n") unless $oreq;
  my $req = Storable::dclone($oreq);	# deep clone
  die unless $req->{'id'} eq $id;
  my $oldstate = $req->{'state'};
  push @{$req->{'history'}}, $oldstate;
  $req->{'state'} = {'name' => $cgi->{'newstate'}};
  $req->{'state'}->{'who'} = $cgi->{'user'} if defined $cgi->{'user'};
  $req->{'state'}->{'comment'} = $cgi->{'comment'} if defined $cgi->{'comment'};
  my @lt = localtime(time());
  $req->{'state'}->{'when'} = sprintf("%04d-%02d-%02dT%02d:%02d:%02d", $lt[5] + 1900, $lt[4] + 1, @lt[3,2,1,0]);
  writereq($oreq, $req);
  $req->{'oldstate'} = $oldstate;
  BSHermes::notify( "SRCSRV_REQUEST_STATECHANGE", BSHermes::requestParams($req, $cgi->{'user'}));
  return $BSStdServer::return_ok;
}

sub delrequest {
  my ($cgi, $id) = @_;
  my $oreq = readxml("$requestsdir/$id", $BSXML::request, 1);
  die("no such request '$id'\n") unless $oreq;
  die unless $oreq->{'id'} eq $id;
  writereq($oreq, undef);
  BSHermes::notify("SRCSRV_REQUEST_DELETE", BSHermes::requestParams($oreq, $cgi->{'user'}));
  return $BSStdServer::return_ok;
}

sub fetchreq {
  my ($db, $key) = @_;
  my $req = readxml("$requestsdir/$key", $BSXML::request, 1) || {};
  $req->{'id'} = $key;
  return $req;
}

sub search_request {
  my ($cgi, $match) = @_;
  my $db = BSDB::opendb($reqindexdb, '');
  $db->{'noindex'} = {'id' => 1};
  $db->{'allkeyspath'} = 'type';
  $db->{'fetch'} = \&fetchreq;
  my $rootnode = BSXPathKeys::node($db, '');
  my $data = BSXPath::match($rootnode, $match) || [];
  my $res = {'request' => $data};
  return ($res, $BSXML::collection);
}

####################################################################

sub findremote {
  my ($projid) = @_;

  my $origprojid = $projid;
  my $proj = readproj($projid, 1);
  if ($proj) {
    return ($BSConfig::reposerver, $projid) if !$proj->{'remoteurl'};
    die("no remoteproject specified\n") unless $proj->{'remoteproject'};
    return ($proj->{'remoteurl'}, $proj->{'remoteproject'});
  }
  my $rsuf = '';
  while ($projid =~ /^(.*)(:.*?)$/) {
    $projid = $1;
    $rsuf = "$2$rsuf";
    $proj = readproj($projid, 1);
    next unless $proj;
    die("project '$origprojid' does not exist\n") unless $proj->{'remoteurl'};
    if ($proj->{'remoteproject'}) {
      return ($proj->{'remoteurl'}, "$proj->{'remoteproject'}$rsuf");
    }
    $rsuf =~ s/^://;
    return ($proj->{'remoteurl'}, $rsuf);
  }
  die("project '$origprojid' does not exist\n") unless $proj->{'remoteurl'};
}

sub worker_getbinaries {
  my ($cgi, $projid, $repoid, $arch) = @_;

  if (!$BSStdServer::isajax) {
    my @args;
    push @args, "project=$projid";
    push @args, "repository=$repoid";
    push @args, "arch=$arch";
    push @args, "binaries=$cgi->{'binaries'}";
    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);
    exit(0);
  }
  my @binaries = split(',', $cgi->{'binaries'});
  my ($remoteurl, $remoteprojid) = findremote($projid);
  my $binarylist = BSWatcher::rpc("$remoteurl/build/$remoteprojid/$repoid/$arch/_repository", $BSXML::binarylist, "view=names", map {"binary=$_"} @binaries);
  return undef if $BSStdServer::isajax && !$binarylist;
  my %binarylist;
  for my $b (@{$binarylist->{'binary'} || []}) {
    if ($b->{'filename'} =~ /^(.*)(\.deb|\.rpm)$/) {
      $binarylist{$1} = $b;
    } else {
      $binarylist{$b->{'filename'}} = $b;
    }
  }
  my @fetch;
  my @reply;

  local *LOCK;
  mkdir_p($remotecache);
  BSUtil::lockopen(\*LOCK, '>>', "$remotecache/lock") || die("$remotecache/lock: $!\n");
  for my $bin (@binaries) {
    my $b = $binarylist{$bin};
    if (!$b || !$b->{'size'} || !$b->{'mtime'}) {
      push @reply, {'name' => $bin, 'error' => 'not available'};
      next;
    }
    my $cachemd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch/$bin");
    substr($cachemd5, 2, 0, '/');
    my @s = stat("$remotecache/$cachemd5");
    if (!@s || $s[9] != $b->{'mtime'} || $s[7] != $b->{'size'}) {
      push @fetch, $bin;
    } else {
      utime time(), $s[9], "$remotecache/$cachemd5";
      push @reply, {'name' => $b->{'filename'}, 'filename' => "$remotecache/$cachemd5"};
    }
  }
  my $slot = sprintf("%02x", (int(rand(256))));
  print "cleaning slot $slot\n";
  if (-d "$remotecache/$slot") {
    my $now = time();
    my $num = 0;
    for my $f (ls("$remotecache/$slot")) {
      my @s = stat("$remotecache/$slot/$f");
      next if $s[8] >= $now - 24*3600;
      unlink("$remotecache/$slot/$f");
      $num++;
    }
    print "removed $num unused files\n" if $num;
  }
  close(LOCK);

  if (@fetch) {
    my $serialmd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch");

    # serialize this upload
    my $serial = BSWatcher::serialize("$remotecache/$serialmd5.lock");
    return undef unless $serial;

    print "fetch: @fetch\n";
    my %fetch = map {$_ => $binarylist{$_}} @fetch;
    my $param = {
      'uri' => "$remoteurl/build/$remoteprojid/$repoid/$arch/_repository",
      'receiver' => \&BSHTTP::cpio_receiver,
      'directory' => $remotecache,
      'map' => "upload$serialmd5:",
    };
    mkdir_p($remotecache);
    my $cpio;
    if ($BSStdServer::isajax) {
      $param->{'receiver'} = \&BSHTTP::file_receiver;
      $param->{'filename'} = "$remotecache/upload$serialmd5.cpio";
      local *F;
      if (open(F, '<', $param->{'filename'})) {
        unlink($param->{'filename'});
	my $hdr = {
	  'content-length' => -s F,
	  '__data' => '',
	  '__socket' => \*F,
        };
	$cpio = BSHTTP::cpio_receiver($hdr, $param);
	close F;
      }
    }

    # work around api bug: only get 50 packages at a time
    @fetch = splice(@fetch, 0, 50) if !$cpio && @fetch > 50;

    $cpio ||= BSWatcher::rpc($param, undef, "view=cpio", map {"binary=$_"} @fetch);
    return undef if $BSStdServer::isajax && !$cpio;
    for my $f (@{$cpio || []}) {
      my $bin = $f->{'name'};
      $bin =~ s/^upload.*?://;
      $bin =~ s/\.(:?rpm|deb)$//;
      if (!$fetch{$bin}) {
        unlink("$remotecache/$f->{'name'}");
	next;
      }
      my $cachemd5 = Digest::MD5::md5_hex("$projid/$repoid/$arch/$bin");
      substr($cachemd5, 2, 0, '/');
      mkdir_p("$remotecache/".substr($cachemd5, 0, 2));
      rename("$remotecache/$f->{'name'}", "$remotecache/$cachemd5");
      push @reply, {'name' => $fetch{$bin}->{'filename'}, 'filename' => "$remotecache/$cachemd5"};
      delete $fetch{$bin};
    }
    BSWatcher::serialize_end($serial);

    if (@{$cpio || []} >= 50) {
      # work around api bug: get rest
      return worker_getbinaries($cgi, $projid, $repoid, $arch);
    }

    for (sort keys %fetch) {
      push @reply, {'name' => $_, 'error' => 'not available'};
    }
  }
  if ($cgi->{'raw'}) {
    die("can only transport one binary in raw mode\n") unless @reply == 1;
    my $f = $reply[0];
    die("$f->{'name'}: $f->{'error'}\n") if $f->{'error'};
    die("$f->{'name'}: not found\n") unless $f->{'filename'};
    BSWatcher::reply_file($f->{'filename'});
    return undef;
  }
  BSWatcher::reply_cpio(\@reply);
  return undef;
}

sub worker_lastevents {
  my ($cgi, $watch) = @_;
  if (!$cgi->{'start'}) {
    # just fetch the current event number
    my $lastev = BSFileDB::fdb_getlast("$eventdir/lastevents", $eventlay);
    my $lastno = $lastev ? $lastev->{'number'} : 0;
    my $ret = {'next' => $lastno, 'sync' => 'lost'};
    return ($ret, $BSXML::events);
  }
  if (!$BSStdServer::isajax) {
    my @args = map {"filter=$_"} @{$watch || []};
    push @args, "start=$cgi->{'start'}";
    BSHandoff::handoff($ajaxsocket, '/lastevents', undef, @args);
    exit(0);
  }
  BSWatcher::addfilewatcher("$eventdir/lastevents");
  my $lastev = BSFileDB::fdb_getlast("$eventdir/lastevents", $eventlay);
  my $lastno = $lastev ? $lastev->{'number'} : 0;
  my $nextno = $lastno + 1;
  my @events;
  if ($cgi->{'start'} == $lastno) {
    push @events, $lastev;
  } elsif ($cgi->{'start'} < $lastno) {
    # multiple events >= start
    push @events, BSFileDB::fdb_getall("$eventdir/lastevents", $eventlay);
    # re-calculate in case something was appended
    $nextno = $events[-1]->{'number'} + 1 if @events;
    if (@events && $events[0]->{'number'} > $cgi->{'start'}) {
      # out of sync!
      return ({'next' => $nextno, 'sync' => 'lost'}, $BSXML::events);
    }
    @events = grep {$_->{'number'} >= $cgi->{'start'}} @events;
  }
  if ($watch && @events) {
    my %watch = map {$_ => 1} @$watch;
    for my $ev (splice @events) {
      if ($ev->{'type'} eq 'package') {
        next unless defined $ev->{'package'};
        next unless $watch{"package/$ev->{'project'}/$ev->{'package'}"};
      } elsif ($ev->{'type'} eq 'project') {
        next unless $watch{"project/$ev->{'project'}"};
      } elsif ($ev->{'type'} eq 'repository') {
        next unless $watch{"repository/$ev->{'project'}/$ev->{'repository'}/$ev->{'arch'}"};
      } else {
	next;
      }
      push @events, $ev;
    }
  }
  # return a sync reply every 100 events for two reasons
  # - get rid of old peers
  # - survive history truncation
  return undef if $BSStdServer::isajax && !@events && $nextno < $cgi->{'start'} + 100;
  for (@events) {
    delete $_->{'time'};
    delete $_->{'number'};
  }
  my $ret = {'next' => $nextno};
  $ret->{'event'} = \@events if @events;
  return ($ret, $BSXML::events);
}

sub addevent {
  my ($ev) = @_;
  $ev->{'time'} = time();
  mkdir_p("$eventdir");
  if (-s "$eventdir/lastevents" && -s _ >= 65536) {
    local *F;
    BSUtil::lockopen(\*F, '+>>', "$eventdir/lastevents");
    my $events = readstr("$eventdir/lastevents");
    if (length($events) >= 65536) {
      $events = substr($events, -32768);
      $events =~ s/^[^\n]*\n//s;
      writestr("$eventdir/.lastevents", "$eventdir/lastevents", $events);
    }
    close F;
  }
  BSFileDB::fdb_add_i("$eventdir/lastevents", $eventlay, $ev);
}

sub newevent {
  my ($cgi) = @_;
  my $ev = {};
  for ('type', 'project', 'package', 'repository', 'arch', 'job') {
    $ev->{$_} = $cgi->{$_} if defined $cgi->{$_};
  }
  addevent($ev);
  return $BSStdServer::return_ok;
}

####################################################################

sub hello {
  my ($cgi) = @_;
  return "<hello name=\"Source Repository Ajax Server\" />\n" if $BSStdServer::isajax;
  return "<hello name=\"Source Repository Server\" />\n";
}

####################################################################

my $dispatches = [
  '/' => \&hello,

  # /platform name space -> obsolete
  '/platform' => \&getprojectlist,
  '/platform/$project' => \&getrepositorylist,
  '/platform/$project/$repository' => \&getrepository,

  # /repository name space -> obsolete
  '/repository' => \&getprojectlist,
  '/repository/$project' => \&getrepositorylist,
  '/repository/$project/$repository' => \&getrepository,

  # /project name space -> obsolete
  '/project' => \&getprojectlist,
  '/project/$project' => \&getproject,
  'PUT:/project/$project' => \&putproject,

  # /package name space -> obsolete
  '/package' => \&getprojectlist,
  '/package/$project' => \&getpackagelist,
  '/package/$project/$package' => \&getpackage,
  'PUT:/package/$project/$package' => \&putpackage,
  'DELETE:/package/$project/$package' => \&delpackage,
  '/package/$project/$package/history' => \&getpackagehistory,

  # /source name space: manage project and package data
  '/source' => \&getprojectlist,
  'POST:/source/$project cmd:' => \&projectcmd,
  '/source/$project' => \&getpackagelist,
  'DELETE:/source/$project' => \&delproject,
  '/source/$project/_meta' => \&getproject,
  'PUT:/source/$project/_meta' => \&putproject,
  '/source/$project/_pubkey' => \&getpubkey,
  'DELETE:/source/$project/_pubkey' => \&deletekey,
  '/source/$project/_config' => \&getprojectconfig,
  'PUT:/source/$project/_config' => \&putprojectconfig,
  'POST:/source/$project/$package cmd: rev? user:? comment:? orev:rev? oproject:project? opackage:package? expand:bool? keeplink:bool?' => \&sourcecmd,
  'PUT:/source/$project/$package cmd: rev? user:? comment:?' => \&sourcecommitfilelist,
  '/source/$project/$package:package_pattern rev? expand:bool? view:? extension:?' => \&getfilelist,
  '/source/$project/$package:package_pattern/_history' => \&getpackagehistory,
  '/source/$project/$package/_meta' => \&getpackage,
  'PUT:/source/$project/$package/_meta' => \&putpackage,
  'DELETE:/source/$project/$package' => \&delpackage,
  '/source/$project/$package:package_pattern/$filename rev?' => \&getfile,
  'PUT:/source/$project/$package:package_pattern/$filename rev? user:? comment:? keeplink:bool?' => \&putfile,
  'DELETE:/source/$project/$package:package_pattern/$filename rev? user:? comment:? keeplink:bool?' => \&delfile,

  # /published name spec: access published binaries
  '/published' => \&published,
  '/published/$project' => \&published,
  '/published/$project/$repository' => \&published,
  '/published/$project/$repository/$arch:filename view:?' => \&published,
  '/published/$project/$repository/$arch:filename/$filename view:?' => \&published,

  # scheduler calls
  '/getprojpack $project* $repository* $package* $arch? withrepos:bool? withsrcmd5:bool? withdeps:bool? withconfig:bool? expandedrepos:bool? ignoredisable:bool? nopackages:bool? withremotemap:bool?' => \&getprojpack,

  # worker calls
  '/getsources $project $package $srcmd5:md5' => \&getsources,
  '/getconfig $project $repository' => \&getconfig,

  '/getsignkey $project withpubkey:bool?' => \&getsignkey,
  '/getbinaries $project $repository $arch binaries: nometa:bool?' => \&worker_getbinaries,
  '/lastevents $filter:* start:num?' => \&worker_lastevents,
  '/event type: project: package:? repository:? arch:? job:?' => \&newevent,
  # tmp until lightty gets fixed
  '/public/lastevents $filter:* start:num?' => \&worker_lastevents,

  # search interface
  '/search $in: $match: return:? values:bool?' => \&search,
  '/search/project $match:' => \&search_proj,
  '/search/project/id $match:' => \&search_proj_id,
  '/search/package $match:' => \&search_pack,
  '/search/package/id $match:' => \&search_pack_id,

  'POST:/search/published cmd:' => \&search_published_updatedb,
  '/search/published/binary/id $match:' => \&search_published_binary_id,
  '/search/published/pattern/id $match:' => \&search_published_pattern_id,

  # build calls for binary files
  '/build' => \&getprojectlist,
  '/build/_workerstatus scheduleronly:bool? arch*' => \&getworkerstatus,
  'POST:/build/$project cmd: repository* arch* package* code:*' => \&docommand,
  '/build/$project' => \&getrepositorylist,
  '/build/$project/_result oldstate:md5? view:resultview* repository* arch* package* code:*' => \&getresult,
  '/build/$project/$repository' => \&getarchlist,
  '/build/$project/$repository/_buildconfig' => \&getconfig,
  '/build/$project/$repository/$arch' => \&getpackagelist,
  'POST:/build/$project/$repository/$arch/_repository match:' =>  \&postrepo,
  '/build/$project/$repository/$arch/$package_repository view:? binary:filename*' => \&getbinarylist,
  'POST:/build/$project/$repository/$arch/$package_repository/_buildinfo add:*' => \&getbuildinfo_post,
  '/build/$project/$repository/$arch/$package/_buildinfo add:* internal:bool?' => \&getbuildinfo,
  '/build/$project/$repository/$arch/$package/_log nostream:bool? start:num? end:num?' => \&getlogfile,
  '/build/$project/$repository/$arch/$package/_status' => \&getbuildstatus,
  '/build/$project/$repository/$arch/$package/_history' => \&getbuildhistory,
  '/build/$project/$repository/$arch/$package_repository/$filename' => \&getbinary,
  'PUT:/build/$project/$repository/$arch/_repository/$filename ignoreolder:bool? wipe:bool?' => \&putbinary,

  'POST:/request cmd: user:?' => \&createrequest,
  '/request' => \&getrequestlist,
  'POST:/request/$id:num cmd: newstate:? user:? comment:?' => \&postrequest,
  '/request/$id:num' => \&getrequest,
  'PUT:/request/$id:num user:?' => \&putrequest,
  'DELETE:/request/$id:num' => \&delrequest,
  '/search/request $match:' => \&search_request,

  '/ajaxstatus' => \&getajaxstatus,
];

####################################################################

my $dispatches_ajax = [
  '/' => \&hello,
  '/ajaxstatus' => \&getajaxstatus,
  '/build/$project/_result oldstate:md5? view:resultview* repository* arch* package* code:*' => \&getresult,
  '/build/$project/$repository/$arch/$package/_log nostream:bool? start:num? end:num?' => \&getlogfile,
  '/build/$project/$repository/$arch/$package_repository view:? binary:filename*' => \&getbinarylist,
  '/getbinaries $project $repository $arch binaries: nometa:bool? raw:bool?' => \&worker_getbinaries,
  '/lastevents $filter:* start:num?' => \&worker_lastevents,
];

####################################################################

my $conf = {
  'port' => $port,
  'dispatches' => $dispatches,
  'setkeepalive' => 1,
  'maxchild' => 20,
};

my $aconf = {
  'socketpath' => $ajaxsocket,
  'dispatches' => $dispatches_ajax,
  'getrequest_timeout' => 10,
  'replrequest_timeout' => 10,
  'getrequest_recvfd' => \&BSHandoff::receive,
  'setkeepalive' => 1,
};

BSHermes::notify("SRCSRV_START", $conf);

BSStdServer::server('bs_srcserver', \@ARGV, $conf, $aconf);

